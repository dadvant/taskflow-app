<!DOCTYPE html>
<!-- TaskFlow v3.0 - Cloud Sync with Firebase
     NEW FEATURES:
     - Firebase Authentication (Google + Email/Password)
     - Cloud storage with Firestore (sync across devices)
     - Secure user authentication
     - Real-time sync
     - All v2.22 features preserved
     Updated: October 6, 2025
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TaskFlow v3.0 - Cloud Sync</title>
    <link rel="stylesheet" href="taskflow-styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#4285f4">
    
    <!-- Firebase SDK v10 (Modular) -->
    <script type="module">
        // ============================================================================
        // FIREBASE CONFIGURATION & INITIALIZATION
        // ============================================================================
        
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { 
            getAuth, 
            signInWithPopup, 
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            GoogleAuthProvider 
        } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { 
            getFirestore, 
            collection, 
            doc, 
            setDoc, 
            getDoc, 
            getDocs,
            deleteDoc,
            onSnapshot,
            query,
            orderBy,
            serverTimestamp
        } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

        // ============================================================================
        // üî• FIREBASE CONFIG - Official Firebase Configuration
        // ============================================================================
        // Firebase project: taskflow-acef2
        // Using official Firebase API key with security rules protection
        
        const firebaseConfig = {
          apiKey: "AIzaSyDGA7PkR2BXN2bx_VCm5yZdRJkuyxWj_rs",
          authDomain: "taskflow-acef2.firebaseapp.com",
          projectId: "taskflow-acef2",
          storageBucket: "taskflow-acef2.firebasestorage.app",
          messagingSenderId: "836379022235",
          appId: "1:836379022235:web:f589fcf2bb93a3d724873e",
          measurementId: "G-L3ZVE2KY56"
        };

        // Initialize Firebase
        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            console.log('üî• Firebase initialized successfully!');
            window.firebaseReady = true;
        } catch (error) {
            console.error('‚ùå Firebase initialization error:', error);
            console.log('‚ö†Ô∏è Running in offline mode. Please configure Firebase to enable cloud sync.');
            window.firebaseReady = false;
        }

        // ============================================================================
        // FIREBASE AUTH & DATA MANAGER
        // ============================================================================
        
        window.FirebaseManager = {
            currentUser: null,
            dataUnsubscribe: null,
            
            // Initialize auth listener
            init() {
                if (!window.firebaseReady) {
                    console.log('Firebase not configured, skipping auth');
                    return;
                }
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        this.currentUser = user;
                        console.log('‚úÖ User logged in:', user.email);
                        this.onLogin(user);
                    } else {
                        this.currentUser = null;
                        console.log('‚ùå User logged out');
                        this.onLogout();
                    }
                });
            },
            
            // Sign in with Google
            async signInWithGoogle() {
                try {
                    const provider = new GoogleAuthProvider();
                    const result = await signInWithPopup(auth, provider);
                    return result.user;
                } catch (error) {
                    console.error('Google sign-in error:', error);
                    this.showError('Google sign-in failed: ' + error.message);
                    throw error;
                }
            },
            
            // Sign in with Email
            async signInWithEmail(email, password) {
                try {
                    const result = await signInWithEmailAndPassword(auth, email, password);
                    return result.user;
                } catch (error) {
                    console.error('Email sign-in error:', error);
                    this.showError(this.getErrorMessage(error));
                    throw error;
                }
            },
            
            // Sign up with Email
            async signUpWithEmail(email, password) {
                try {
                    const result = await createUserWithEmailAndPassword(auth, email, password);
                    return result.user;
                } catch (error) {
                    console.error('Sign-up error:', error);
                    this.showError(this.getErrorMessage(error));
                    throw error;
                }
            },
            
            // Sign out
            async signOut() {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error('Sign-out error:', error);
                    throw error;
                }
            },
            
            // Handle login
            onLogin(user) {
                document.getElementById('loginModal')?.classList.remove('show');
                document.getElementById('app-container')?.style.removeProperty('display');
                
                const userEmail = document.getElementById('userEmail');
                const userEmailFull = document.getElementById('userEmailFull');
                const userAvatar = document.getElementById('userAvatar');
                
                if (userEmail) userEmail.textContent = user.email || 'User';
                if (userEmailFull) userEmailFull.textContent = user.email || 'User';
                if (userAvatar) userAvatar.textContent = (user.email?.[0] || 'U').toUpperCase();
                
                // Migrate localStorage to Firestore
                this.migrateToFirestore(user.uid);
                
                // Initialize app with Firestore
                if (window.app) {
                    window.app.initWithFirestore(user.uid);
                }
            },
            
            // Handle logout
            onLogout() {
                document.getElementById('loginModal')?.classList.add('show');
                document.getElementById('app-container')?.style.setProperty('display', 'none');
                
                // Stop listening to Firestore
                if (this.dataUnsubscribe) {
                    this.dataUnsubscribe();
                    this.dataUnsubscribe = null;
                }
            },
            
            // Migrate localStorage to Firestore (one-time)
            async migrateToFirestore(userId) {
                try {
                    // Check if user already has data in Firestore
                    const migrationDoc = await getDoc(doc(db, `users/${userId}/settings/migration`));
                    if (migrationDoc.exists() && migrationDoc.data().completed) {
                        console.log('‚úÖ Migration already completed for this user');
                        return;
                    }

                    console.log('üÜï New user detected - starting with empty task list');
                    
                    // DO NOT migrate localStorage - each user starts fresh!
                    // localStorage might contain data from another user's browser session
                    
                    // Just mark migration as complete so new users start clean
                    await setDoc(doc(db, `users/${userId}/settings/migration`), {
                        completed: true,
                        timestamp: new Date().toISOString(),
                        startedClean: true  // Flag to indicate this user started with no migrated data
                    });

                    console.log('‚úÖ User initialized with empty task list');
                } catch (error) {
                    console.error('‚ùå Migration error:', error);
                }
            },
            
            // Save task
            async saveTask(userId, task) {
                await setDoc(doc(db, `users/${userId}/tasks/${task.id}`), task);
            },
            
            // Delete task
            async deleteTask(userId, taskId) {
                await deleteDoc(doc(db, `users/${userId}/tasks/${taskId}`));
            },
            
            // Get tasks
            async getTasks(userId) {
                const snapshot = await getDocs(collection(db, `users/${userId}/tasks`));
                const tasks = [];
                snapshot.forEach(doc => tasks.push(doc.data()));
                return tasks;
            },
            
            // Listen to tasks
            listenToTasks(userId, callback) {
                this.dataUnsubscribe = onSnapshot(
                    collection(db, `users/${userId}/tasks`),
                    (snapshot) => {
                        const tasks = [];
                        snapshot.forEach(doc => tasks.push(doc.data()));
                        callback(tasks);
                    }
                );
            },
            
            // Listen to projects in real-time
            listenToProjects(userId, callback) {
                this.projectsUnsubscribe = onSnapshot(
                    collection(db, `users/${userId}/projects`),
                    (snapshot) => {
                        const projects = [];
                        snapshot.forEach(doc => projects.push(doc.data()));
                        callback(projects);
                    }
                );
            },
            
            // Save project
            async saveProject(userId, project) {
                await setDoc(doc(db, `users/${userId}/projects/${project.id}`), project);
            },
            
            // Delete project
            async deleteProject(userId, projectId) {
                await deleteDoc(doc(db, `users/${userId}/projects/${projectId}`));
            },
            
            // Get projects
            async getProjects(userId) {
                const snapshot = await getDocs(collection(db, `users/${userId}/projects`));
                const projects = [];
                snapshot.forEach(doc => projects.push(doc.data()));
                return projects;
            },
            
            // Error messages
            getErrorMessage(error) {
                const messages = {
                    'auth/email-already-in-use': 'Email already in use',
                    'auth/weak-password': 'Password too weak (min 6 characters)',
                    'auth/invalid-email': 'Invalid email address',
                    'auth/user-not-found': 'User not found',
                    'auth/wrong-password': 'Incorrect password',
                    'auth/popup-closed-by-user': 'Sign-in cancelled'
                };
                return messages[error.code] || error.message;
            },
            
            // Show error
            showError(message) {
                const errorEl = document.getElementById('authError');
                if (errorEl) {
                    errorEl.textContent = message;
                    errorEl.style.display = 'block';
                    setTimeout(() => errorEl.style.display = 'none', 5000);
                }
            }
        };

        // Initialize on load
        if (window.firebaseReady) {
            window.FirebaseManager.init();
        }
        
        console.log('‚úÖ Firebase module loaded');
    </script>
    
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <!-- EmailJS for client-side email sending -->
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
</head>
<body data-theme="light">
    <!-- Login Modal (Shows when not authenticated) -->
    <div id="loginModal" class="modal show" style="z-index: 10000;">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header" style="border-bottom: 1px solid var(--border-color);">
                <h2 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-tasks" style="color: var(--primary-color);"></i>
                    Welcome to TaskFlow v3.0
                </h2>
            </div>
            <div class="modal-body" style="padding: 30px 24px;">
                <!-- Error Message -->
                <div id="authError" style="display: none; background: #fee; color: #c00; padding: 12px; border-radius: 6px; margin-bottom: 20px; font-size: 14px;"></div>
                
                <!-- Sign In Tab -->
                <div id="signInTab">
                    <h3 style="margin: 0 0 20px 0; color: var(--text-primary); font-size: 18px;">Sign In</h3>
                    
                    <!-- Google Sign In -->
                    <button onclick="handleGoogleSignIn()" class="btn btn--primary" style="width: 100%; padding: 12px; font-size: 15px; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <i class="fab fa-google"></i>
                        Sign in with Google
                    </button>
                    
                    <div style="text-align: center; margin: 20px 0; color: var(--text-secondary); font-size: 14px;">
                        or
                    </div>
                    
                    <!-- Email/Password Sign In -->
                    <form id="signInForm" onsubmit="handleEmailSignIn(event)" style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 6px; color: var(--text-primary); font-size: 14px;">Email</label>
                            <input type="email" id="signInEmail" required style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; background: var(--bg-primary); color: var(--text-primary);">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 6px; color: var(--text-primary); font-size: 14px;">Password</label>
                            <input type="password" id="signInPassword" required style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; background: var(--bg-primary); color: var(--text-primary);">
                        </div>
                        <button type="submit" class="btn btn--secondary" style="width: 100%; padding: 10px; font-size: 15px;">
                            Sign In
                        </button>
                    </form>
                    
                    <div style="text-align: center; margin-top: 20px; color: var(--text-secondary); font-size: 14px;">
                        Don't have an account? 
                        <a href="#" onclick="showSignUp(); return false;" style="color: var(--primary-color); text-decoration: none; font-weight: 500;">Sign Up</a>
                    </div>
                </div>
                
                <!-- Sign Up Tab (Hidden by default) -->
                <div id="signUpTab" style="display: none;">
                    <h3 style="margin: 0 0 20px 0; color: var(--text-primary); font-size: 18px;">Create Account</h3>
                    
                    <!-- Google Sign Up -->
                    <button onclick="handleGoogleSignIn()" class="btn btn--primary" style="width: 100%; padding: 12px; font-size: 15px; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <i class="fab fa-google"></i>
                        Sign up with Google
                    </button>
                    
                    <div style="text-align: center; margin: 20px 0; color: var(--text-secondary); font-size: 14px;">
                        or
                    </div>
                    
                    <!-- Email/Password Sign Up -->
                    <form id="signUpForm" onsubmit="handleEmailSignUp(event)" style="display: flex; flex-direction: column; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 6px; color: var(--text-primary); font-size: 14px;">Email</label>
                            <input type="email" id="signUpEmail" required style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; background: var(--bg-primary); color: var(--text-primary);">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 6px; color: var(--text-primary); font-size: 14px;">Password <span style="color: var(--text-secondary); font-size: 12px;">(min 6 characters)</span></label>
                            <input type="password" id="signUpPassword" required minlength="6" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; background: var(--bg-primary); color: var(--text-primary);">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 6px; color: var(--text-primary); font-size: 14px;">Confirm Password</label>
                            <input type="password" id="signUpPasswordConfirm" required minlength="6" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; font-size: 14px; background: var(--bg-primary); color: var(--text-primary);">
                        </div>
                        <button type="submit" class="btn btn--secondary" style="width: 100%; padding: 10px; font-size: 15px;">
                            Create Account
                        </button>
                    </form>
                    
                    <div style="text-align: center; margin-top: 20px; color: var(--text-secondary); font-size: 14px;">
                        Already have an account? 
                        <a href="#" onclick="showSignIn(); return false;" style="color: var(--primary-color); text-decoration: none; font-weight: 500;">Sign In</a>
                    </div>
                </div>
                
                <!-- Info Text -->
                <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 13px; line-height: 1.6;">
                    <strong style="color: var(--text-primary);">New in v3.0:</strong>
                    <ul style="margin: 10px 0 0 20px; padding: 0;">
                        <li>‚òÅÔ∏è Cloud storage with Firebase</li>
                        <li>üîÑ Real-time sync across devices</li>
                        <li>üîí Secure authentication</li>
                        <li>üì± Access from laptop, phone, or tablet</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main App Container (Hidden until logged in) -->
    <div id="app-container" style="display: none;">
    <!-- Mobile Header -->
    <header class="mobile-header">
        <button class="hamburger-btn" id="hamburgerBtn">
            <i class="fas fa-bars"></i>
        </button>
        <div class="logo">
            <i class="fas fa-tasks"></i>
            <span>TaskFlow v3.0</span>
        </div>
        <div class="header-actions">
            <!-- User Profile -->
            <div class="user-profile" style="display: flex; align-items: center; gap: 8px; margin-right: 12px; cursor: pointer;" onclick="document.getElementById('userMenu').classList.toggle('show');">
                <div id="userAvatar" style="width: 32px; height: 32px; border-radius: 50%; background: var(--primary-color); color: white; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px;">U</div>
                <span id="userEmail" style="color: var(--text-primary); font-size: 14px; display: none;">user@email.com</span>
            </div>
            
            <!-- User Dropdown Menu -->
            <div id="userMenu" class="dropdown-menu" style="display: none; position: absolute; top: 50px; right: 60px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: var(--shadow); min-width: 200px; z-index: 1000;">
                <div style="padding: 12px; border-bottom: 1px solid var(--border-color);">
                    <div style="font-weight: 600; color: var(--text-primary); font-size: 14px;" id="userEmailFull">user@email.com</div>
                    <div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">TaskFlow v3.0</div>
                </div>
                <button onclick="handleSignOut()" style="width: 100%; padding: 12px; text-align: left; background: none; border: none; color: var(--text-primary); cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 14px;" onmouseover="this.style.background='var(--bg-secondary)'" onmouseout="this.style.background='none'">
                    <i class="fas fa-sign-out-alt"></i>
                    Sign Out
                </button>
            </div>
            
            <button class="theme-toggle" id="themeToggle">
                <i class="fas fa-moon"></i>
            </button>
        </div>
    </header>

    <!-- Sidebar Navigation -->
    <nav class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="logo">
                <i class="fas fa-tasks"></i>
                <span>TaskFlow v3.0</span>
            </div>
            <button class="close-sidebar" id="closeSidebar">
                <i class="fas fa-times"></i>
            </button>
        </div>

        <div class="sidebar-content">
            <!-- Views Section -->
            <div class="sidebar-section">
                <h3>VIEWS</h3>
                <ul class="sidebar-menu">
                    <li class="menu-item" data-view="today">
                        <i class="fas fa-calendar-day"></i>
                        <span>Today</span>
                        <span class="count" id="todayCount">0</span>
                    </li>
                    <li class="menu-item" data-view="upcoming">
                        <i class="fas fa-calendar-alt"></i>
                        <span>Upcoming</span>
                        <span class="count" id="upcomingCount">0</span>
                    </li>
                    <li class="menu-item" data-view="all">
                        <i class="fas fa-list"></i>
                        <span>All Tasks</span>
                        <span class="count" id="allCount">0</span>
                    </li>
                    <li class="menu-item active" data-view="matrix">
                        <i class="fas fa-th"></i>
                        <span>Board View</span>
                    </li>
                    <li class="menu-item" data-view="calendar">
                        <i class="fas fa-calendar"></i>
                        <span>Calendar</span>
                    </li>
                    <li class="menu-item" data-view="completed">
                        <i class="fas fa-check-circle"></i>
                        <span>Completed</span>
                        <span class="count" id="completedCount">0</span>
                    </li>
                </ul>
            </div>

            <!-- Projects Section -->
            <div class="sidebar-section">
                <div class="section-header">
                    <h3>PROJECTS</h3>
                    <button class="add-project-btn" id="addProjectBtn">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <ul class="sidebar-menu" id="projectsList">
                    <!-- Projects will be loaded dynamically -->
                </ul>
            </div>

            <!-- Tags Section -->
            <div class="sidebar-section">
                <div class="section-header">
                    <h3>TAGS</h3>
                    <button class="add-project-btn" id="addTagBtn">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <ul class="sidebar-menu" id="tagsList">
                    <!-- Tags will be loaded dynamically -->
                </ul>
            </div>

            <!-- Tools Section -->
            <div class="sidebar-section">
                <h3>TOOLS</h3>
                <ul class="sidebar-menu">
                    <li class="menu-item" data-action="meetings">
                        <i class="fas fa-video"></i>
                        <span>Meetings</span>
                    </li>
                    <li class="menu-item" data-action="analytics">
                        <i class="fas fa-chart-line"></i>
                        <span>Analytics</span>
                    </li>
                    <li class="menu-item" data-action="settings">
                        <i class="fas fa-cog"></i>
                        <span>Settings</span>
                    </li>
                </ul>
            </div>
        </div>

        <!-- Mini Calendar in Sidebar -->
        <div class="sidebar-calendar">
            <div class="calendar-header">
                <button class="calendar-nav" id="prevMonth">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <span class="calendar-title" id="calendarTitle">Oct 2025</span>
                <button class="calendar-nav" id="nextMonth">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            <div class="calendar-grid" id="calendarGrid">
                <!-- Calendar will be generated here -->
            </div>
        </div>
    </nav>

    <!-- Overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Main Content -->
    <main class="main-content">
        <div class="content-header">
            <div class="view-info">
                <h1 id="currentViewTitle">Priority Matrix</h1>
                <p id="currentViewSubtitle">Eisenhower Decision Matrix</p>
            </div>
            <div class="view-actions">
                <button class="btn btn--secondary" id="filterBtn">
                    <i class="fas fa-filter"></i>
                    Filter
                </button>
                <button class="btn btn--primary" id="addTaskBtn">
                    <i class="fas fa-plus"></i>
                    Add Task
                </button>
            </div>
        </div>

        <!-- Quick Stats -->
        <div class="quick-stats">
            <div class="stat-item">
                <div class="stat-value" id="totalTasksStat">0</div>
                <div class="stat-label">Total Tasks</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="completedTodayStat">0</div>
                <div class="stat-label">Completed Today</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="overdueStat">0</div>
                <div class="stat-label">Overdue</div>
            </div>
        </div>

        <!-- Filter Panel -->
        <div class="filter-panel" id="filterPanel" style="display: none;">
            <div class="filter-group">
                <label>Priority:</label>
                <select id="priorityFilter">
                    <option value="">All Priorities</option>
                    <option value="important-immediate">Important & Immediate</option>
                    <option value="important-not-immediate">Important & Not Immediate</option>
                    <option value="immediate-not-important">Immediate & Not Important</option>
                    <option value="not-important-not-immediate">Not Important & Not Immediate</option>
                </select>
            </div>
            <div class="filter-group">
                <label>Tags:</label>
                <input type="text" id="tagFilter" placeholder="Filter by tags...">
            </div>
            <div class="filter-group">
                <label>Project:</label>
                <select id="projectFilter">
                    <option value="">All Projects</option>
                </select>
            </div>
            <div class="filter-group">
                <button class="btn btn--secondary btn--small" id="clearFiltersBtn">
                    <i class="fas fa-times"></i>
                    Clear Filters
                </button>
            </div>
        </div>

        <!-- Task Views -->
        <div class="task-views">
            <!-- Today View -->
            <div id="todayView" class="task-view">
                <div id="todayTasks" class="task-list">
                    <!-- Tasks will be loaded here -->
                </div>
            </div>

            <!-- Upcoming View -->
            <div id="upcomingView" class="task-view">
                <div id="upcomingTasks" class="task-list">
                    <!-- Tasks will be loaded here -->
                </div>
            </div>

            <!-- All Tasks View -->
            <div id="allView" class="task-view">
                <div id="allTasks" class="task-list">
                    <!-- Tasks will be loaded here -->
                </div>
            </div>

            <!-- Priority Matrix View - DEFAULT -->
            <div id="matrixView" class="task-view active">
                <div class="priority-matrix">
                    <!-- Do First - Important & Immediate -->
                    <div class="matrix-quadrant" data-quadrant="important-immediate">
                        <div class="quadrant-header">
                            <h3 class="quadrant-main-label">Do First <span class="priority-color" style="background: #ef4444;"></span></h3>
                            <span class="quadrant-sub-label">Important & Immediate</span>
                        </div>
                        <div class="quadrant-tasks" id="matrix-important-immediate"></div>
                    </div>
                    
                    <!-- Do First - Not Important but Immediate -->
                    <div class="matrix-quadrant" data-quadrant="immediate-not-important-urgent">
                        <div class="quadrant-header">
                            <h3 class="quadrant-main-label">Do First <span class="priority-color" style="background: #ff6b6b;"></span></h3>
                            <span class="quadrant-sub-label">Not Important but Immediate</span>
                        </div>
                        <div class="quadrant-tasks" id="matrix-immediate-not-important-urgent"></div>
                    </div>
                    
                    <!-- Schedule - Important but Not Immediate -->
                    <div class="matrix-quadrant" data-quadrant="important-not-immediate">
                        <div class="quadrant-header">
                            <h3 class="quadrant-main-label">Schedule <span class="priority-color" style="background: #f59e0b;"></span></h3>
                            <span class="quadrant-sub-label">Important but Not Immediate</span>
                        </div>
                        <div class="quadrant-tasks" id="matrix-important-not-immediate"></div>
                    </div>
                    
                    <!-- Delegate - Shareable Lists -->
                    <div class="matrix-quadrant" data-quadrant="immediate-not-important">
                        <div class="quadrant-header-with-share">
                            <div class="quadrant-header">
                                <h3 class="quadrant-main-label">Delegate <span class="priority-color" style="background: #10b981;"></span></h3>
                                <span class="quadrant-sub-label">Shareable Lists</span>
                            </div>
                            <button class="delegate-share-btn" onclick="window.app.emailDelegateTasks()" title="Share all delegate tasks">
                                üìß Share
                            </button>
                        </div>
                        <div class="quadrant-tasks" id="matrix-immediate-not-important"></div>
                    </div>
                    
                    <!-- Eliminate - Not Important & Not Immediate -->
                    <div class="matrix-quadrant" data-quadrant="not-important-not-immediate">
                        <div class="quadrant-header">
                            <h3 class="quadrant-main-label">Eliminate <span class="priority-color" style="background: #6b7280;"></span></h3>
                            <span class="quadrant-sub-label">Not Important & Not Immediate</span>
                        </div>
                        <div class="quadrant-tasks" id="matrix-not-important-not-immediate"></div>
                    </div>
                </div>
            </div>

            <!-- Calendar View -->
            <div id="calendarView" class="task-view">
                <div class="calendar-view-header">
                    <button class="btn btn--secondary" id="prevWeek">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <h2 id="calendarViewTitle">October 2025</h2>
                    <button class="btn btn--secondary" id="nextWeek">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <div class="calendar-main" id="calendarMain">
                    <!-- Full calendar will be generated here -->
                </div>
            </div>

            <!-- Completed View -->
            <div id="completedView" class="task-view">
                <div id="completedTasks" class="task-list">
                    <!-- Completed tasks will be loaded here -->
                </div>
            </div>
        </div>
    </main>

    <!-- Add Task Modal - ENHANCED -->
    <div id="addTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Add New Task</h2>
                <div class="modal-header-actions">
                    <button type="button" class="btn btn--secondary" id="cancelTask">Cancel</button>
                    <button type="submit" class="btn btn--primary" form="taskForm">Add Task</button>
                    <button class="close-btn" id="closeTaskModal">&times;</button>
                </div>
            </div>
            <div class="modal-body">
                <!-- AI Suggestions Panel -->
                <div id="aiSuggestionsPanel" class="ai-suggestions-panel" style="display: none;">
                    <div class="ai-suggestion-header">
                        <i class="fas fa-brain"></i>
                        <h4>AI Suggestions</h4>
                        <div class="ai-confidence" id="aiConfidence"></div>
                    </div>
                    <div id="aiSuggestionsList" class="ai-suggestions-list"></div>
                </div>

                <form id="taskForm">
                    <div class="form-group">
                        <label for="taskTitle">Title:</label>
                        <input type="text" id="taskTitle" required placeholder="What needs to be done?">
                    </div>

                    <div class="form-group">
                        <label for="taskDescription">Description:</label>
                        <textarea id="taskDescription" placeholder="Add more details..."></textarea>
                    </div>

                    <!-- Priority Selection - FIXED WIDTH -->
                    <div class="form-group">
                        <label>Priority:</label>
                        <div class="priority-selection">
                            <div class="priority-grid-fixed">
                                <button type="button" class="priority-option-fixed" data-priority="important-immediate">
                                    <i class="fas fa-fire"></i>
                                    <span class="priority-text">Important & Immediate</span>
                                </button>
                                <button type="button" class="priority-option-fixed" data-priority="important-not-immediate">
                                    <i class="fas fa-star"></i>
                                    <span class="priority-text">Important & Not Immediate</span>
                                </button>
                                <button type="button" class="priority-option-fixed" data-priority="immediate-not-important">
                                    <i class="fas fa-bolt"></i>
                                    <span class="priority-text">Immediate & Not Important</span>
                                </button>
                                <button type="button" class="priority-option-fixed selected" data-priority="not-important-not-immediate">
                                    <i class="fas fa-circle"></i>
                                    <span class="priority-text">Not Important & Not Immediate</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Project Selection (Chips) -->
                    <div class="form-group">
                        <label>Project:</label>
                        <div class="project-chips" id="projectChips">
                            <!-- Project chips will be added dynamically -->
                        </div>
                        <input type="hidden" id="taskProject" value="">
                    </div>

                    <!-- Tags -->
                    <div class="form-group">
                        <label for="taskTags">Tags:</label>
                        <input type="text" id="taskTags" placeholder="Enter tags separated by commas">
                        <div class="tag-suggestions">
                            <label style="font-size: 12px; color: var(--text-secondary); margin-top: 8px; display: block;">üí° Suggested tags (click to add):</label>
                            <div class="suggested-tags" id="suggestedTags">
                                <!-- AI-suggested tags will appear here -->
                            </div>
                        </div>
                    </div>

                    <!-- Due Date and Time -->
                    <div class="form-row">
                        <div class="form-group">
                            <label for="taskDate">Due Date:</label>
                            <input type="date" id="taskDate">
                        </div>
                        <div class="form-group">
                            <label for="taskTime">Time:</label>
                            <input type="time" id="taskTime">
                        </div>
                    </div>

                    <!-- Recurring Options - NEW -->
                    <div class="form-group">
                        <label for="taskRecurrence">Recurrence:</label>
                        <select id="taskRecurrence">
                            <option value="none">No Recurrence</option>
                            <option value="daily">Every Day</option>
                            <option value="weekly">Every Week</option>
                            <option value="monthly">Every Month</option>
                            <option value="first-of-month">First Day of Month</option>
                            <option value="last-of-month">Last Day of Month</option>
                            <option value="weekdays">Weekdays Only</option>
                            <option value="custom">Custom...</option>
                        </select>
                    </div>

                    <!-- Recurrence End Date - NEW -->
                    <div class="form-group" id="recurrenceEndGroup" style="display: none;">
                        <label for="recurrenceEnd">Recurrence Ends:</label>
                        <div class="recurrence-end-options">
                            <label>
                                <input type="radio" name="recurrenceEndType" value="never" checked>
                                Never
                            </label>
                            <label>
                                <input type="radio" name="recurrenceEndType" value="date">
                                On Date: <input type="date" id="recurrenceEndDate" disabled>
                            </label>
                            <label>
                                <input type="radio" name="recurrenceEndType" value="count">
                                After: <input type="number" id="recurrenceCount" min="1" max="999" disabled> occurrences
                            </label>
                        </div>
                    </div>

                    <!-- Calendar Event Options - ENHANCED -->
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="createCalendarEvent">
                            Create calendar event
                        </label>
                        <small class="ai-info">
                            <i class="fas fa-robot"></i> 
                            AI will automatically analyze your task and create calendar reminders when needed
                        </small>
                        
                        <!-- AI Reminder Preview -->
                        <div id="aiReminderPreview" class="ai-reminder-preview">
                            <h5><i class="fas fa-robot"></i> AI Reminder Analysis</h5>
                            <p id="aiReminderReason">AI is analyzing your task...</p>
                            <div class="ai-confidence-meter">
                                <span>Confidence:</span>
                                <div class="confidence-bar">
                                    <div class="confidence-fill" id="aiConfidenceFill" style="width: 0%"></div>
                                </div>
                                <span id="aiConfidenceText">0%</span>
                            </div>
                            <small id="aiReminderNote">üí° This analysis updates as you fill in task details</small>
                        </div>
                        
                        <div id="calendarEventOptions" class="calendar-options" style="display: none;">
                            <div class="form-group">
                                <label for="eventDuration">Duration (minutes):</label>
                                <input type="number" id="eventDuration" value="60" min="15" step="15">
                            </div>
                            <div class="form-group">
                                <label for="eventParticipants">Participants (emails):</label>
                                <input type="text" id="eventParticipants" placeholder="email1@example.com, email2@example.com">
                            </div>
                            <div class="form-group">
                                <label for="eventCalendar">Calendar Account:</label>
                                <select id="eventCalendar">
                                    <option value="">Select connected calendar</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="addMeetingLink" checked>
                                    Add meeting link
                                </label>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Settings Modal - ENHANCED CALENDAR SECTION -->
    <div id="settingsModal" class="modal">
        <div class="modal-content large">
            <div class="modal-header">
                <h2><i class="fas fa-cog"></i> TaskFlow v3.0 Settings</h2>
                <button class="close-btn" id="closeSettingsModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="settings-tabs">
                    <button class="settings-tab active" data-tab="appearance">
                        <i class="fas fa-palette"></i>
                        Appearance
                    </button>
                    <button class="settings-tab" data-tab="calendar">
                        <i class="fas fa-calendar-alt"></i>
                        Calendar
                    </button>
                    <button class="settings-tab" data-tab="ai">
                        <i class="fas fa-brain"></i>
                        AI Analysis
                    </button>
                    <button class="settings-tab" data-tab="general">
                        <i class="fas fa-sliders-h"></i>
                        General
                    </button>
                    <button class="settings-tab" data-tab="data">
                        <i class="fas fa-database"></i>
                        Data
                    </button>
                </div>

                <!-- Complete Settings Content -->
                <div id="settingsContent">
                    <!-- Appearance Tab -->
                    <div id="appearanceTab" class="settings-content active">
                        <h3>üé® Appearance & Themes</h3>

                        <div class="settings-section">
                            <h4>Theme</h4>
                            <div class="theme-options">
                                <label class="theme-option" data-theme="light">
                                    <input type="radio" name="theme" value="light" checked>
                                    <div class="theme-preview light-theme">
                                        <div class="theme-header"></div>
                                        <div class="theme-content"></div>
                                    </div>
                                    <span>Light Theme</span>
                                </label>

                                <label class="theme-option" data-theme="dark">
                                    <input type="radio" name="theme" value="dark">
                                    <div class="theme-preview dark-theme">
                                        <div class="theme-header"></div>
                                        <div class="theme-content"></div>
                                    </div>
                                    <span>Dark Theme</span>
                                </label>

                                <label class="theme-option" data-theme="auto">
                                    <input type="radio" name="theme" value="auto">
                                    <div class="theme-preview auto-theme">
                                        <div class="theme-header"></div>
                                        <div class="theme-content"></div>
                                    </div>
                                    <span>Auto (System)</span>
                                </label>
                            </div>
                        </div>


                    </div>

                    <!-- Calendar Tab - ENHANCED -->
                    <div id="calendarTab" class="settings-content">
                        <h3>üìÖ Calendar Integration</h3>

                        <div class="settings-section">
                            <h4>Connect Calendar Providers</h4>
                            <div class="calendar-providers">
                                <!-- EXACT WORKING BUTTON FROM googlecalendar FOLDER -->
                                <button class="btn btn--primary" id="connectGoogleCalendar" 
                                        onclick="console.log('üî• BUTTON CLICKED!'); openGoogleAuthModal(); return false;">
                                    <i class="fab fa-google"></i>
                                    Connect Google Calendar
                                </button>
                            </div>
                        </div>

                        <!-- Connected Accounts Table - NEW -->
                        <div class="settings-section">
                            <h4>Connected Accounts</h4>
                            <div class="connected-accounts">
                                <table class="accounts-table" id="connectedAccountsTable">
                                    <thead>
                                        <tr>
                                            <th>Provider</th>
                                            <th>Account Name</th>
                                            <th>Email</th>
                                            <th>Calendars</th>
                                            <th>Status</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr class="no-accounts">
                                            <td colspan="6" class="text-center">
                                                <i class="fas fa-calendar-plus" style="font-size: 2rem; color: var(--text-tertiary); margin-bottom: 1rem;"></i>
                                                <p>No calendar accounts connected</p>
                                                <p class="small">Connect your Google, Outlook, or Apple calendar to get started</p>
                                            </td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- DEBUGGING AND RESET SECTION -->
                        <div class="settings-section">
                            <h4>üîß Calendar Troubleshooting</h4>
                            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                                <button class="btn btn--small btn--secondary" onclick="window.diagnoseGoogleCalendar()" title="Check calendar connection status">
                                    <i class="fas fa-stethoscope"></i> Diagnose Connection
                                </button>
                                <button class="btn btn--small btn--success" onclick="createTestEvent()" title="Create a test calendar event to verify connection">
                                    <i class="fas fa-calendar-plus"></i> Send Test Event
                                </button>
                                <button class="btn btn--small btn--warning" onclick="resetAndReconnect()" title="Reset Google Calendar completely">
                                    <i class="fas fa-redo"></i> Reset & Reconnect
                                </button>
                            </div>
                            
                            <!-- Diagnostic Results Table -->
                            <div id="calendarDiagnostics" class="diagnostics-container" style="display: none; margin-top: 15px;">
                                <div style="background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; padding: 0; overflow: hidden;">
                                    <div style="background: var(--bg-tertiary); padding: 12px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
                                        <h5 style="margin: 0; font-weight: 600; color: var(--text-primary);">üîç Calendar Connection Status</h5>
                                        <button onclick="document.getElementById('calendarDiagnostics').style.display='none'" style="background: none; border: none; font-size: 18px; cursor: pointer; padding: 4px; color: var(--text-secondary); font-weight: bold;" title="Close">
                                            <i class="fas fa-times"></i>
                                        </button>
                                    </div>
                                    <div style="padding: 15px;">
                                        <table class="accounts-table diagnostics-table" id="diagnosticsTable" style="width: 100%; border-collapse: collapse;">
                                            <thead>
                                                <tr style="background: var(--bg-tertiary); border-bottom: 2px solid var(--border-color);">
                                                    <th style="padding: 12px; text-align: left; color: var(--text-primary); font-weight: 600;">Check</th>
                                                    <th style="padding: 12px; text-align: left; color: var(--text-primary); font-weight: 600;">Status</th>
                                                    <th style="padding: 12px; text-align: left; color: var(--text-primary); font-weight: 600;">Details</th>
                                                </tr>
                                            </thead>
                                            <tbody id="diagnosticsTableBody">
                                                <!-- Results will be populated here -->
                                            </tbody>
                                        </table>
                                        <div id="diagnosticsRecommendation" style="margin-top: 15px; padding: 12px; background: var(--warning-color); color: #1a1a1a; border: 1px solid #f59e0b; border-radius: 4px; display: none;">
                                            <!-- Recommendations will appear here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4>Calendar Settings</h4>
                            <div class="form-group">
                                <label for="defaultCalendar">Default Calendar:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <select id="defaultCalendar" style="flex: 1;">
                                        <option value="">Select a calendar</option>
                                    </select>
                                    <button type="button" id="refreshCalendars" class="btn btn--small btn--secondary" 
                                            onclick="app.debugRefreshCalendars()" title="Refresh calendar list">
                                        <i class="fas fa-sync-alt"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="reminderMinutes">Default Reminder:</label>
                                <select id="reminderMinutes">
                                    <option value="0">No reminder</option>
                                    <option value="5">5 minutes</option>
                                    <option value="10">10 minutes</option>
                                    <option value="15" selected>15 minutes</option>
                                    <option value="30">30 minutes</option>
                                    <option value="60">1 hour</option>
                                    <option value="120">2 hours</option>
                                    <option value="1440">1 day</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="autoCreateEvents" checked>
                                    Automatically create calendar events for tasks with due dates
                                </label>
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="autoDeleteEvents" checked>
                                    Automatically delete calendar events when tasks are deleted
                                </label>
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="syncTaskCompletion">
                                    Mark calendar events as completed when tasks are done
                                </label>
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="syncRecurringTasks" checked>
                                    Create recurring calendar events for recurring tasks
                                </label>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4>Meeting Integration</h4>
                            <div class="form-group">
                                <label for="meetingProvider">Meeting Provider:</label>
                                <select id="meetingProvider">
                                    <option value="google-meet">Google Meet</option>
                                    <option value="zoom">Zoom</option>
                                    <option value="teams">Microsoft Teams</option>
                                    <option value="custom">Custom</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="autoAddMeetingLinks" checked>
                                    Automatically add meeting links to calendar events
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- AI Assistant Tab - AI Reminder Detection Only -->
                    <div id="aiTab" class="settings-content">
                        <h3>ü§ñ AI Task Analysis</h3>

                        <div class="settings-section">
                            <h4>Automatic Calendar Events</h4>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="enableAiReminders" checked>
                                    Enable AI reminder detection
                                </label>
                                <small>Automatically create calendar events when tasks contain reminder keywords ("remind", "meeting", "call", etc.)</small>
                            </div>
                            <div class="form-group">
                                <label for="aiConfidenceThreshold">AI Confidence Threshold:</label>
                                <select id="aiConfidenceThreshold">
                                    <option value="50">50% - More sensitive</option>
                                    <option value="70" selected>70% - Balanced</option>
                                    <option value="90">90% - Only obvious reminders</option>
                                </select>
                                <small>How confident the AI should be before creating calendar events</small>
                            </div>
                            <div class="form-group">
                                <p><strong>How it works:</strong></p>
                                <ul style="margin-left: 20px; color: var(--text-secondary);">
                                    <li>AI analyzes task descriptions for reminder keywords</li>
                                    <li>Automatically creates Google Calendar events for detected reminders</li>
                                    <li>Calendar provides notifications - no additional email setup needed</li>
                                    <li>Works with tasks containing: "remind", "meeting", "call", "appointment", "follow up", etc.</li>
                                </ul>
                            </div>
                        </div>
                    </div>

                    <!-- General Tab -->
                    <div id="generalTab" class="settings-content">
                        <h3>‚öôÔ∏è General Settings</h3>

                        <div class="settings-section">
                            <h4>Default Behavior</h4>
                            <div class="form-group">
                                <label for="defaultView">Default View:</label>
                                <select id="defaultView">
                                    <option value="today">Today</option>
                                    <option value="upcoming">Upcoming</option>
                                    <option value="all">All Tasks</option>
                                    <option value="matrix" selected>Board View</option>
                                    <option value="calendar">Calendar</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="taskSortOrder">Task Sort Order:</label>
                                <select id="taskSortOrder">
                                    <option value="priority" selected>Priority</option>
                                    <option value="dueDate">Due Date</option>
                                    <option value="created">Created Date</option>
                                    <option value="alphabetical">Alphabetical</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label for="weekStartDay">Week Starts On:</label>
                                <select id="weekStartDay">
                                    <option value="0">Sunday</option>
                                    <option value="1" selected>Monday</option>
                                    <option value="6">Saturday</option>
                                </select>
                            </div>
                        </div>






                    </div>

                    <!-- Data Tab -->
                    <div id="dataTab" class="settings-content">
                        <h3>üíæ Data Management</h3>

                        <div class="settings-section">
                            <h4>Data Export</h4>
                            <p>Export your tasks and projects to backup or transfer to another device.</p>
                            <div class="export-buttons">
                                <button class="btn btn--primary" id="exportJSON">
                                    <i class="fas fa-download"></i>
                                    Export as JSON
                                </button>
                                <button class="btn btn--secondary" id="exportCSV">
                                    <i class="fas fa-file-csv"></i>
                                    Export as CSV
                                </button>
                                <button class="btn btn--secondary" id="exportICS">
                                    <i class="fas fa-calendar-alt"></i>
                                    Export as iCal
                                </button>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4>Data Import</h4>
                            <p>Import tasks from a backup file or another task management system.</p>
                            <div class="import-area">
                                <input type="file" id="importFile" accept=".json,.csv,.ics" style="display: none;">
                                <button class="btn btn--primary" id="importButton">
                                    <i class="fas fa-upload"></i>
                                    Import Data
                                </button>
                                <div id="importStatus" class="import-status"></div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4>Storage Information</h4>
                            <div class="storage-info">
                                <div class="storage-item">
                                    <span>Total Tasks:</span>
                                    <span id="totalTasksCount">0</span>
                                </div>
                                <div class="storage-item">
                                    <span>Active Tasks:</span>
                                    <span id="activeTasksCount">0</span>
                                </div>
                                <div class="storage-item">
                                    <span>Completed Tasks:</span>
                                    <span id="completedTasksCount">0</span>
                                </div>
                                <div class="storage-item">
                                    <span>Projects:</span>
                                    <span id="totalProjectsCount">0</span>
                                </div>
                                <div class="storage-item">
                                    <span>Storage Used:</span>
                                    <span id="storageUsed">0 KB</span>
                                </div>
                            </div>
                        </div>

                        <div class="settings-section">
                            <h4>Data Cleanup</h4>
                            <p>Clean up your data to free up storage space.</p>
                            <div class="cleanup-buttons">
                                <button class="btn btn--secondary" id="cleanCompletedTasks">
                                    <i class="fas fa-broom"></i>
                                    Archive Completed Tasks (30+ days)
                                </button>
                                <button class="btn btn--secondary" id="cleanEmptyProjects">
                                    <i class="fas fa-folder-minus"></i>
                                    Remove Empty Projects
                                </button>
                            </div>
                        </div>

                        <div class="settings-section danger-zone">
                            <h4>‚ö†Ô∏è Danger Zone</h4>
                            <p>These actions cannot be undone. Please be careful.</p>
                            <div class="danger-buttons">
                                <button class="btn btn--danger" id="clearAllData">
                                    <i class="fas fa-trash-alt"></i>
                                    Clear All Data
                                </button>
                                <button class="btn btn--danger" id="resetSettings">
                                    <i class="fas fa-undo"></i>
                                    Reset All Settings
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Task Expanded Modal -->
    <div id="taskExpandedModal" class="task-expanded-modal">
        <div class="task-expanded-content">
            <div class="task-expanded-header">
                <h2 class="task-expanded-title" id="expandedTaskTitle">Task Title</h2>
                <button class="task-expanded-close" onclick="app.closeExpandedTask()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="task-expanded-body" id="expandedTaskBody">
                <!-- Task details will be populated here -->
            </div>
        </div>
    </div>

    <!-- EXACT WORKING GOOGLE CALENDAR FROM googlecalendar FOLDER -->
    <div id="googleAuthModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2><i class="fab fa-google"></i> Google Calendar Integration</h2>
                <button class="close-btn" onclick="closeGoogleAuthModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- EXACT COPY FROM WORKING googlecalendar/index.html -->
                <div id="authorize-div" style="display: none; text-align: center; padding: 20px;">
                    <p><strong>‚úÖ You're signed in with Google!</strong></p>
                    <p>Just one more click to add Calendar permissions to your existing Google account:</p>
                    <button id="authorize-button" class="btn btn--primary btn--large" onclick="handleAuthClick()">
                        <i class="fab fa-google"></i> Add Calendar Access
                    </button>
                    <p style="margin-top: 12px; font-size: 13px; color: #666;">
                        This will use your existing Google account - no need to sign in again!
                    </p>
                </div>
                
                <div id="signout-div" style="display: none; text-align: center; padding: 20px;">
                    <p>‚úÖ Google Calendar is connected!</p>
                    <button id="signout-button" class="btn btn--secondary" onclick="handleSignoutClick()">
                        <i class="fas fa-sign-out-alt"></i> Sign Out
                    </button>
                    <hr>
                    <div style="margin-top: 20px;">
                        <h4>Test Google Calendar:</h4>
                        <button onclick="createTestEvent()" class="btn btn--success">
                            <i class="fas fa-calendar-plus"></i> Test Calendar Event
                        </button>
                        <button onclick="debugEmailSettings()" class="btn btn--info" style="margin-left: 8px;">
                            <i class="fas fa-bug"></i> Debug Email Settings
                        </button>
                        <small style="display: block; margin-top: 8px; color: #666;">
                            Creates a test calendar event to verify Google Calendar integration is working
                        </small>
                    </div>
                </div>

                <div id="calendar-loading" style="text-align: center; padding: 20px;">
                    <p>Loading Google Calendar API...</p>
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom CSS for Fixed Priority Buttons -->
    <style>
        /* User Dropdown Menu */
        .dropdown-menu {
            display: none;
        }
        
        .dropdown-menu.show {
            display: block !important;
        }
        
        /* CSS Theme Variables - EXACT v2.13 Colors */
        :root {
            /* Primary colors */
            --primary-color: #4285f4;
            --secondary-color: #34a853;
            --error-color: #ea4335;
            --warning-color: #fbbc04;

            /* Light Theme Variables */
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #e9ecef;
            --text-primary: #212529;
            --text-secondary: #6c757d;
            --text-tertiary: #adb5bd;
            --border-color: #dee2e6;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
            --shadow-hover: 0 4px 20px rgba(0,0,0,0.15);

            /* Sidebar */
            --sidebar-bg: #1a1d23;
            --sidebar-text: #ffffff;
            --sidebar-text-secondary: #9ca3af;
            --sidebar-hover: #2d3748;
            --sidebar-active: #4285f4;
        }

        /* Dark Theme Variables - Darker Slate Colors */
        [data-theme="dark"], .dark {
            --bg-primary: #1e293b;
            --bg-secondary: #334155;
            --bg-tertiary: #475569;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --border-color: #475569;
            --shadow: 0 2px 10px rgba(0,0,0,0.4);
            --shadow-hover: 0 4px 20px rgba(0,0,0,0.5);

            /* Dark Sidebar */
            --sidebar-bg: #0f172a;
            --sidebar-text: #f1f5f9;
            --sidebar-text-secondary: #94a3b8;
            --sidebar-hover: #1e293b;
            --sidebar-active: #3b82f6;
        }

        /* Modal Header with Actions */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }

        .modal-header h2 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .modal-header-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .modal-header-actions .btn {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .modal-header-actions .btn--primary {
            background: var(--primary-color);
            color: white;
        }

        .modal-header-actions .btn--primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .modal-header-actions .btn--secondary {
            background: transparent;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .modal-header-actions .btn--secondary:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 28px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Base body styling - EXACT v2.13 */
        body {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        /* Tables in dark mode */
        table {
            color: var(--text-primary);
            width: 100%;
        }

        table thead th {
            background: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
            border-color: var(--border-color) !important;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        table tbody td {
            background: transparent !important;
            color: var(--text-primary) !important;
            border-color: var(--border-color) !important;
            padding: 10px 12px;
        }

        table tbody tr {
            border-bottom: 1px solid var(--border-color);
        }

        /* Diagnostic modal specific */
        .diagnostics-table {
            border-collapse: collapse;
        }

        .diagnostics-table tbody td {
            padding: 12px;
            vertical-align: middle;
        }

        .diagnostics-table .status-ok {
            color: #34a853 !important;
            font-weight: 600;
        }

        .diagnostics-table .status-failed {
            color: #ea4335 !important;
            font-weight: 600;
        }

        /* Ensure text in diagnostic rows is always visible */
        #diagnosticsTableBody tr td {
            color: var(--text-primary) !important;
        }

        #diagnosticsTableBody tr td:first-child {
            color: var(--text-secondary) !important;
        }

        /* Quadrant styling - EXACT v2.13 */
        .matrix-quadrant {
            flex: 1;
            min-width: 300px;
            height: 400px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-primary);
            border-radius: 12px;
            margin: 8px;
            padding: 20px;
            box-shadow: var(--shadow);
            min-height: 400px;
        }

        /* No additional dark theme needed - uses CSS variables */
        .matrix-quadrant:hover {
            box-shadow: var(--shadow-hover);
        }

        /* Stat boxes - EXACT v2.13 */
        .stat-item {
            background: var(--bg-primary);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            box-shadow: var(--shadow);
            transition: transform 0.2s;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .priority-grid-fixed {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 8px;
        }

        .priority-option-fixed {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 60px;
            width: 100%;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 14px;
            text-align: left;
        }

        .priority-option-fixed:hover {
            border-color: var(--primary-color);
            background: var(--bg-primary);
            transform: translateY(-1px);
        }

        .priority-option-fixed.selected {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            font-weight: 600;
        }

        .priority-option-fixed i {
            font-size: 16px;
            width: 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .priority-text {
            font-size: 14px;
            line-height: 1.3;
            flex: 1;
            word-wrap: break-word;
        }

        /* Project Chips */
        .project-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            max-height: 120px;
            overflow-y: auto;
            padding: 4px 0;
        }

        .project-chips .chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: 2px solid var(--border-color);
            border-radius: 20px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .project-chips .chip:hover {
            border-color: var(--primary-color);
            background: var(--bg-primary);
            transform: translateY(-1px);
        }

        .project-chips .chip.selected {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .project-chips .chip i {
            font-size: 12px;
        }

        /* Tag Suggestions */
        .tag-suggestions {
            margin-top: 12px;
        }

        .suggested-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .suggested-tags .tag-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            border: 1px dashed var(--border-color);
            border-radius: 16px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }

        .suggested-tags .tag-chip:hover {
            border-style: solid;
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: white;
            transform: scale(1.05);
        }

        .suggested-tags .tag-chip i {
            font-size: 10px;
        }

        /* Recurrence styles */
        .recurrence-end-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 8px;
        }

        .recurrence-end-options label {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recurrence-end-options input[type="date"],
        .recurrence-end-options input[type="number"] {
            margin-left: 8px;
            width: auto;
        }

        /* Connected accounts table */
        .accounts-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
        }

        .accounts-table th,
        .accounts-table td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid var(--border-color, #e5e7eb);
        }

        .accounts-table th {
            background-color: var(--bg-secondary, #f8fafc);
            font-weight: 600;
            font-size: 14px;
        }

        .accounts-table td {
            font-size: 14px;
        }

        .accounts-table .text-center {
            text-align: center;
        }

        /* Diagnostics container specific styling */
        .diagnostics-container {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            color: var(--text-primary);
        }

        .diagnostics-container .accounts-table th {
            color: #1e293b !important;
            background-color: #f1f5f9 !important;
            font-weight: 600 !important;
            border-bottom: 2px solid #e2e8f0 !important;
        }

        .diagnostics-container .accounts-table td {
            color: #374151 !important;
            border-bottom: 1px solid #e2e8f0 !important;
        }

        .diagnostics-container .accounts-table tr:hover {
            background-color: #f8fafc !important;
        }

        .provider-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .provider-google {
            background-color: #fef3c7;
            color: #d97706;
        }

        .provider-outlook {
            background-color: #dbeafe;
            color: #2563eb;
        }

        .provider-apple {
            background-color: #f3f4f6;
            color: #374151;
        }

        .status-connected {
            color: #059669;
            font-weight: 500;
        }

        .status-error {
            color: #dc2626;
            font-weight: 500;
        }

        .account-actions {
            display: flex;
            gap: 4px;
        }

        .account-actions .btn {
            font-size: 12px;
            padding: 4px 8px;
        }

        /* Simple Auth Styles (like working app) */
        .auth-simple {
            max-width: 400px;
            margin: 0 auto;
        }

        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--primary-color, #3b82f6);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .btn--large {
            font-size: 16px !important;
            padding: 12px 24px !important;
            border-radius: 8px !important;
        }

        /* Task Item Styles - EXACT v2.13 */
        /* Regular task list (Today/All/Completed views) - use bg-primary */
        .task-item {
            position: relative !important;
            margin-bottom: 12px;
            padding: 20px;
            background: var(--bg-primary);
            border-radius: 12px;
            box-shadow: var(--shadow);
            transition: all 0.2s;
            border-left: 4px solid transparent;
        }

        .task-item:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-1px);
        }

        /* Matrix tasks (inside quadrants) - use bg-secondary for contrast */
        .quadrant-tasks .task-item {
            background: var(--bg-secondary);
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 8px;
            border-left: none;
            box-shadow: none;
        }

        .quadrant-tasks .task-item:hover {
            background: var(--bg-tertiary);
            transform: translateY(-1px);
        }

        /* Priority border colors - EXACT v2.13 */
        .task-item.priority-important-immediate {
            border-left-color: #ef4444;
        }

        .task-item.priority-important-not-immediate {
            border-left-color: #f59e0b;
        }

        .task-item.priority-immediate-not-important {
            border-left-color: #10b981;
        }

        .task-item.priority-not-important-not-immediate {
            border-left-color: #6b7280;
        }

        /* Completed tasks - EXACT v2.13 */
        .task-item.completed {
            opacity: 0.6;
            background: var(--bg-secondary);
        }

        .task-item.overdue {
            background-color: rgba(239, 68, 68, 0.1) !important;
            border-left: 4px solid #ef4444;
        }

        .task-indicators {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 4px;
            z-index: 10;
        }

        .task-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            font-size: 11px;
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .task-indicator.reminder-sent {
            background: linear-gradient(135deg, #10b981, #059669);
            animation: pulse-success 2s infinite;
        }

        .task-indicator.ai-suggests {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            animation: pulse-ai 2s infinite;
        }

        .task-indicator.calendar-created {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
        }

        @keyframes pulse-success {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(16, 185, 129, 0);
            }
        }

        @keyframes pulse-ai {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(139, 92, 246, 0);
            }
        }

        /* AI Reminder Preview in Task Form */
        .ai-reminder-preview {
            background: var(--bg-primary);
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            padding: 16px;
            margin-top: 16px;
            display: none;
            box-shadow: var(--shadow);
        }

        .ai-reminder-preview.show {
            display: block;
            animation: slideDown 0.3s ease-out;
        }

        .ai-reminder-preview h5 {
            color: var(--primary-color);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 16px;
        }

        .ai-confidence-meter {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 12px 0;
        }

        .confidence-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid var(--border-color);
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--error-color), var(--warning-color), var(--secondary-color));
            transition: width 0.5s ease;
            border-radius: 3px;
        }
        
        #aiReminderReason {
            color: var(--text-primary);
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        #aiReminderNote {
            color: var(--text-secondary);
            font-size: 14px;
            font-style: italic;
        }
        
        #aiConfidenceText {
            color: var(--text-primary);
            font-weight: 600;
            min-width: 35px;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Task Action Icons */
        .task-actions {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }

        .task-item {
            position: relative;
        }

        .task-item:hover .task-actions {
            opacity: 1;
        }

        .task-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 12px;
        }

        .task-content {
            flex: 1;
        }

        /* Ensure task items work well in matrix */
        .matrix-quadrant .task-item {
            margin-bottom: 12px;
        }
        
        .matrix-quadrant .task-actions {
            opacity: 1; /* Always show actions in matrix */
        }

        /* Quadrant Header Hierarchy Styles */
        .quadrant-main-label {
            margin: 0 !important;
            font-weight: bold !important;
            font-size: 16px !important;
            color: var(--text-primary) !important;
            display: inline !important;
        }

        .quadrant-sub-label {
            margin: 0 0 16px 8px !important;
            font-size: 12px !important;
            font-weight: normal !important;
            color: var(--text-secondary) !important;
            opacity: 0.8 !important;
            display: inline !important;
        }

        .quadrant-header-with-share {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .quadrant-header {
            margin-bottom: 16px;
        }

        .priority-color {
            display: inline-block !important;
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            margin-left: 8px !important;
            vertical-align: middle !important;
        }

        .delegate-share-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .delegate-share-btn:hover {
            background: var(--primary-hover);
        }

        /* Keep original side-by-side layout for 5 quadrants */
        .priority-matrix {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        .quadrant-tasks {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        /* Matrix Task Actions */
        .matrix-task-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 8px;
        }

        .matrix-task-content {
            flex: 1;
        }

        .matrix-task-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        /* Ensure task actions are always visible in all views */
        .task-list .task-actions {
            opacity: 1;
        }

        .task-view .task-actions {
            opacity: 1;
        }

        .task-action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .task-action-btn.edit {
            background: rgba(59, 130, 246, 0.1);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .task-action-btn.edit:hover {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .task-action-btn.delete {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .task-action-btn.delete:hover {
            background: #ef4444;
            color: white;
            border-color: #ef4444;
        }

        .task-action-btn.expand {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .task-action-btn.expand:hover {
            background: #10b981;
            color: white;
            border-color: #10b981;
        }

        /* Task Expanded Modal */
        .task-expanded-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .task-expanded-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .task-expanded-content {
            background: var(--bg-primary);
            border-radius: 12px;
            padding: 24px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .task-expanded-modal.show .task-expanded-content {
            transform: scale(1);
        }

        .task-expanded-header {
            display: flex;
            justify-content: between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .task-expanded-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
            flex: 1;
            margin-right: 16px;
        }

        .task-expanded-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .task-expanded-close:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .task-expanded-body {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .task-detail-row {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .task-detail-label {
            font-weight: 600;
            color: var(--text-secondary);
            min-width: 80px;
            font-size: 14px;
        }

        .task-detail-value {
            color: var(--text-primary);
            flex: 1;
            font-size: 14px;
            line-height: 1.5;
        }

        .task-priority-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .task-priority-badge.important-immediate {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        .task-priority-badge.important-not-immediate {
            background: rgba(245, 158, 11, 0.1);
            color: #f59e0b;
        }

        .task-priority-badge.immediate-not-important {
            background: rgba(16, 185, 129, 0.1);
            color: #10b981;
        }

        .task-priority-badge.not-important-not-immediate {
            background: rgba(107, 114, 128, 0.1);
            color: #6b7280;
        }

        .task-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .task-tag {
            background: var(--primary-color-10);
            color: var(--primary-color);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Filter Panel Styles */
        .filter-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group:last-child {
            margin-bottom: 0;
        }

        .filter-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 4px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .filter-group select,
        .filter-group input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }

        .filter-group select:focus,
        .filter-group input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.2);
        }

        #clearFiltersBtn {
            margin-top: 8px;
            width: 100%;
        }
    </style>

    <!-- Scripts -->
    <!-- Removed conflicting intelligent-calendar-system.js -->
    
    <!-- Simple Google Calendar Integration (like working app) -->
    <script>
// GOOGLE CALENDAR CODE - CONFIGURED FOR YOUR PROJECT
// Get your OAuth Client ID from: https://console.cloud.google.com/apis/credentials
const CLIENT_ID = '836379022235-f50uv8i0v2pl1rmj47dkt8ue42d8kbii.apps.googleusercontent.com';
const API_KEY = 'AIzaSyDGA7PkR2BXN2bx_VCm5yZdRJkuyxWj_rs';
const SCOPES = 'https://www.googleapis.com/auth/calendar';

let tokenClient;
let gapiInited = false;
let gisInited = false;

/**
 * Sign in the user upon button click (EXACT WORKING VERSION)
 */
function handleAuthClick() {
    console.log('üî• Auth button clicked!');
    
    // Disable button and show loading
    const authButton = document.getElementById('authorize-button');
    if (authButton) {
        authButton.disabled = true;
        authButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Opening Google Sign-In...';
    }
    
    if (!tokenClient) {
        console.error('‚ùå TokenClient not initialized');
        alert('Google authentication not ready. Please refresh the page.');
        if (authButton) {
            authButton.disabled = false;
            authButton.innerHTML = '<i class="fab fa-google"></i> Authorize Google Calendar';
        }
        return;
    }
    
    // Set callback for this specific request
    tokenClient.callback = async (resp) => {
        const authButton = document.getElementById('authorize-button');
        
        if (resp.error !== undefined) {
            console.error('‚ùå Auth error:', resp.error);
            alert('Authentication failed: ' + resp.error);
            // Re-enable button
            if (authButton) {
                authButton.disabled = false;
                authButton.innerHTML = '<i class="fab fa-google"></i> Authorize Google Calendar';
            }
            return;
        }
        
        try {
            console.log('‚úÖ Auth success! Processing...');
            
            // Save token FIRST
            const token = gapi.client.getToken();
            if (token) {
                if (!token.expires_at && token.expires_in) {
                    token.expires_at = Date.now() + (token.expires_in * 1000);
                } else if (!token.expires_at) {
                    token.expires_at = Date.now() + (60 * 60 * 1000);
                }
                localStorage.setItem('google_access_token', JSON.stringify(token));
                console.log('üíæ Token saved');
            }
            
            // Get user email using tokeninfo endpoint (doesn't require API enablement)
            let email = null;
            try {
                const currentToken = gapi.client.getToken();
                if (currentToken && currentToken.access_token) {
                    console.log('üîç Fetching user info via tokeninfo endpoint...');
                    const response = await fetch(`https://www.googleapis.com/oauth2/v3/tokeninfo?access_token=${currentToken.access_token}`);
                    if (response.ok) {
                        const tokenInfo = await response.json();
                        console.log('üì• Token info response:', tokenInfo);
                        email = tokenInfo.email;
                        if (email) {
                            localStorage.setItem('google_account_email', email);
                            console.log('üìß Email saved to localStorage:', email);
                        } else {
                            console.warn('‚ö†Ô∏è No email in tokeninfo response');
                        }
                    } else {
                        console.error('‚ùå Tokeninfo request failed:', response.status, response.statusText);
                    }
                }
            } catch (emailError) {
                console.error('‚ùå Failed to get user email:', emailError);
                email = localStorage.getItem('google_account_email');
                console.log('üìß Using email from localStorage fallback:', email);
            }
            
            // CRITICAL: Also save to the calendarAccounts array for proper persistence
            if (window.app && email) {
                const existingGoogleAccount = window.app.calendarAccounts.find(acc => acc.provider === 'google');
                if (!existingGoogleAccount) {
                    const newAccount = {
                        provider: 'google',
                        accountName: 'Primary Account',
                        email: email,
                        calendars: ['Primary Calendar'],
                        status: 'connected',
                        connectedAt: new Date().toISOString()
                    };
                    window.app.calendarAccounts.push(newAccount);
                    localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(window.app.calendarAccounts));
                    console.log('üíæ Saved Google account to calendarAccounts array');
                } else {
                    // Update existing account
                    existingGoogleAccount.email = email;
                    existingGoogleAccount.status = 'connected';
                    existingGoogleAccount.connectedAt = new Date().toISOString();
                    localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(window.app.calendarAccounts));
                    console.log('üîÑ Updated existing Google account in calendarAccounts array');
                }
            }
            
            // Clear timeout if auth succeeded
            if (tokenClient && tokenClient.timeoutId) {
                clearTimeout(tokenClient.timeoutId);
                tokenClient.timeoutId = null;
            }
            
            // Update UI
            document.getElementById('authorize-div').style.display = 'none';
            document.getElementById('signout-div').style.display = 'block';
            
            // Close modal
            const modal = document.getElementById('googleAuthModal');
            if (modal) {
                modal.style.display = 'none';
                console.log('‚úÖ Modal closed');
            }
            
            // Update TaskFlow state
            if (window.app) {
                window.app.updateGoogleCalendarConnectedState(true);
                window.app.forceUpdateConnectedAccountsTable();
                window.app.showNotification('Google Calendar connected successfully!', 'success');
                
                // Fetch calendars
                setTimeout(async () => {
                    try {
                        await window.app.fetchAndCacheCalendars();
                        await window.app.forcePopulateCalendarDropdown();
                    } catch (e) {
                        console.warn('Could not fetch calendars:', e);
                        await window.app.forcePopulateCalendarDropdown();
                    }
                }, 500);
            }
            
        } catch (error) {
            console.error('‚ùå Error in auth callback:', error);
            alert('Setup failed: ' + error.message);
            // Re-enable button
            const authButton = document.getElementById('authorize-button');
            if (authButton) {
                authButton.disabled = false;
                authButton.innerHTML = '<i class="fab fa-google"></i> Authorize Google Calendar';
            }
        }
    };
    
    // Request access token with proper popup handling
    try {
        // Set a timeout to re-enable button if user closes popup
        const timeoutId = setTimeout(() => {
            const authButton = document.getElementById('authorize-button');
            if (authButton && authButton.disabled) {
                authButton.disabled = false;
                authButton.innerHTML = '<i class="fab fa-google"></i> Authorize Google Calendar';
                console.log('‚è±Ô∏è Auth timeout - re-enabled button');
            }
        }, 60000); // 60 seconds timeout
        
        // Store timeout ID to clear it if auth succeeds
        tokenClient.timeoutId = timeoutId;
        
        if (gapi.client.getToken() === null) {
            // First time auth - request consent and force account selection
            tokenClient.requestAccessToken({
                prompt: 'select_account consent',
                include_granted_scopes: true
            });
        } else {
            // Subsequent auth - just request token
            tokenClient.requestAccessToken({
                prompt: '',
                include_granted_scopes: true
            });
        }
    } catch (error) {
        console.error('‚ùå Request failed:', error);
        alert('Authentication request failed: ' + error.message);
        // Re-enable button
        const authButton = document.getElementById('authorize-button');
        if (authButton) {
            authButton.disabled = false;
            authButton.innerHTML = '<i class="fab fa-google"></i> Authorize Google Calendar';
        }
    }
}

/**
 * Sign out the user upon button click (EXACT WORKING VERSION)
 */
function handleSignoutClick() {
    const token = gapi.client.getToken();
    if (token !== null) {
        google.accounts.oauth2.revoke(token.access_token);
        gapi.client.setToken('');
        document.getElementById('authorize-div').style.display = 'block';
        document.getElementById('signout-div').style.display = 'none';
        
        // Clear localStorage
        localStorage.removeItem('google_account_email');
        localStorage.removeItem('default_calendar_id');
        localStorage.removeItem('google_access_token');
        console.log('üóëÔ∏è Cleared Google account data from localStorage');
        
        // Update TaskFlow UI
        if (window.app) {
            // Remove Google account from calendarAccounts array
            window.app.calendarAccounts = window.app.calendarAccounts.filter(acc => acc.provider !== 'google');
            localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(window.app.calendarAccounts));
            console.log('üóëÔ∏è Removed Google account from calendarAccounts array');
            
            window.app.updateGoogleCalendarConnectedState(false);
            window.app.showNotification('Google Calendar disconnected', 'success');
            
            // üî• FORCE UI CLEAR
            window.app.clearConnectedAccountsTable();
        }
    }
}

/**
 * Helper: Make Calendar API REST calls (bypasses blocked gapi.client.calendar)
 */
async function calendarAPICall(method, endpoint, body = null) {
    const token = gapi.client.getToken();
    if (!token || !token.access_token) {
        throw new Error('No valid access token');
    }
    
    const baseURL = 'https://www.googleapis.com/calendar/v3';
    const url = `${baseURL}${endpoint}`;
    
    const options = {
        method: method,
        headers: {
            'Authorization': `Bearer ${token.access_token}`,
            'Content-Type': 'application/json'
        }
    };
    
    if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
        options.body = JSON.stringify(body);
    }
    
    const response = await fetch(url, options);
    
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Calendar API ${method} ${endpoint} failed: ${response.status} ${response.statusText} - ${errorText}`);
    }
    
    return await response.json();
}

/**
 * Create a calendar event (EXACT WORKING VERSION FROM googlecalendar/app.js)
 */
async function createEvent(eventDetails) {
    try {
        const event = {
            summary: eventDetails.title,
            location: eventDetails.location,
            description: eventDetails.description,
            start: {
                dateTime: eventDetails.startDateTime,
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            },
            end: {
                dateTime: eventDetails.endDateTime,
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            },
            attendees: eventDetails.attendees,
            reminders: {
                useDefault: false,
                overrides: [
                    {method: 'email', minutes: 24 * 60},
                    {method: 'popup', minutes: 10},
                ],
            },
        };

        // Use direct REST API call instead of gapi.client.calendar
        const result = await calendarAPICall('POST', '/calendars/primary/events', event);
        return result;
    } catch (err) {
        console.error('Error creating event:', err);
        throw err;
    }
}

/**
 * Create test event (RESTORED SIMPLE WORKING VERSION)
 */
async function createTestEvent() {
    try {
        console.log('üß™ Creating test calendar event...');
        
        // Check prerequisites first
        if (typeof gapi === 'undefined' || !gapi.client) {
            throw new Error('Google API not loaded');
        }
        
        const token = gapi.client.getToken();
        if (!token) {
            throw new Error('Not authenticated with Google Calendar. Please connect first.');
        }
        
        // Simple test - just create a Google Calendar event like the original working version
        const now = new Date();
        const startTime = new Date(now.getTime() + 60*60*1000); // 1 hour from now
        const endTime = new Date(startTime.getTime() + 60*60*1000); // 1 hour duration
        
        const eventDetails = {
            title: 'üß™ TaskFlow Test Event',
            description: 'This is a test event created by TaskFlow to verify Google Calendar integration is working correctly.',
            location: 'TaskFlow App',
            startDateTime: startTime.toISOString(),
            endDateTime: endTime.toISOString(),
            attendees: []
        };
        
        console.log('ÔøΩ Creating event:', eventDetails);
        
        // Use direct REST API call
        const eventResource = {
            'summary': eventDetails.title,
            'description': eventDetails.description,
            'start': {
                'dateTime': eventDetails.startDateTime,
                'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone
            },
            'end': {
                'dateTime': eventDetails.endDateTime,
                'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone
            }
        };
        
        const result = await calendarAPICall('POST', '/calendars/primary/events', eventResource);
        
        console.log('‚úÖ Event created successfully:', result);
        
        // Show success notification
        if (window.app && window.app.showNotification) {
            window.app.showNotification('‚úÖ Test event created successfully in Google Calendar!', 'success');
        }
        
        alert(`‚úÖ Test Successful!

üìÖ Google Calendar event created successfully!

üîó Event Link: ${result.htmlLink || 'Event created in your calendar'}

‚è∞ Start Time: ${startTime.toLocaleString()}
üìç Location: ${eventDetails.location}
üìù Description: ${eventDetails.description}

The test proves your Google Calendar integration is working correctly!`);
        
    } catch (error) {
        console.error('‚ùå Test failed:', error);
        
        let errorMessage = `‚ùå Test Failed

Error: ${error.message}

Possible solutions:
1. Make sure you clicked "Connect Google Calendar" first
2. Check that you're signed in to your Google account
3. Verify your internet connection
4. Try "Reset & Reconnect" if the problem persists
5. Check the browser console (F12) for more details

üìã Use "Diagnose Connection" button to check what's wrong.`;
        
        alert(errorMessage);
        
        // Show error notification  
        if (window.app && window.app.showNotification) {
            window.app.showNotification('Test event failed: ' + error.message, 'error');
        }
    }
}

/**
 * Debug email settings and configuration
 */
function debugEmailSettings() {
    console.log('üîç === EMAIL SETTINGS DEBUG ===');
    
    // Check localStorage values
    const googleEmail = localStorage.getItem('google_account_email');
    const userEmail = localStorage.getItem('userEmail');
    const googleToken = localStorage.getItem('google_access_token');
    const emailjsService = localStorage.getItem('emailjsServiceId');
    const emailjsTemplate = localStorage.getItem('emailjsTemplateId');
    const emailjsPublicKey = localStorage.getItem('emailjsPublicKey');
    const enableEmail = localStorage.getItem('enableEmailReminders');
    
    const debugInfo = {
        'Google Calendar': {
            'Connected Email': googleEmail || '‚ùå Not found',
            'Access Token': googleToken ? '‚úÖ Present' : '‚ùå Missing',
            'Calendar Ready': (typeof isGoogleCalendarReady !== 'undefined' && isGoogleCalendarReady()) ? '‚úÖ Yes' : '‚ùå No'
        },
        'Email Settings': {
            'User Email': userEmail || '‚ùå Not set',
            'EmailJS Service ID': emailjsService || '‚ùå Not set',
            'EmailJS Template ID': emailjsTemplate || '‚ùå Not set', 
            'EmailJS Public Key': emailjsPublicKey || '‚ùå Not set',
            'Email Reminders Enabled': enableEmail !== 'false' ? '‚úÖ Yes' : '‚ùå No'
        },
        'Available Email': googleEmail || userEmail || '‚ùå None found'
    };
    
    console.log('üìä Debug Results:', debugInfo);
    
    let message = 'üîç EMAIL SETTINGS DEBUG REPORT:\n\n';
    
    // Google Calendar Section
    message += 'üìÖ GOOGLE CALENDAR:\n';
    message += `‚Ä¢ Email: ${googleEmail || '‚ùå Not connected'}\n`;
    message += `‚Ä¢ Token: ${googleToken ? '‚úÖ Present' : '‚ùå Missing'}\n`;
    message += `‚Ä¢ Status: ${(typeof isGoogleCalendarReady !== 'undefined' && isGoogleCalendarReady()) ? '‚úÖ Ready' : '‚ùå Not ready'}\n\n`;
    
    // Email Settings Section  
    message += 'üìß EMAIL SETTINGS:\n';
    message += `‚Ä¢ Your Email: ${userEmail || '‚ùå Not configured'}\n`;
    message += `‚Ä¢ Service ID: ${emailjsService || '‚ùå Not configured'}\n`;
    message += `‚Ä¢ Template ID: ${emailjsTemplate || '‚ùå Not configured'}\n`;
    message += `‚Ä¢ Public Key: ${emailjsPublicKey || '‚ùå Not configured'}\n`;
    message += `‚Ä¢ Enabled: ${enableEmail !== 'false' ? '‚úÖ Yes' : '‚ùå No'}\n\n`;
    
    // Final Assessment
    const hasGoogleEmail = !!googleEmail;
    const hasUserEmail = !!userEmail;
    const hasEmailJS = !!(emailjsService && emailjsTemplate && emailjsPublicKey);
    
    message += 'üéØ REMINDER CAPABILITY:\n';
    message += `‚Ä¢ Calendar Reminders: ${hasGoogleEmail ? '‚úÖ Available' : '‚ùå Need Google Calendar'}\n`;
    message += `‚Ä¢ Email Reminders: ${hasEmailJS && (hasGoogleEmail || hasUserEmail) ? '‚úÖ Available' : '‚ùå Need EmailJS setup'}\n\n`;
    
    if (!hasGoogleEmail && !hasUserEmail) {
        message += '‚ö†Ô∏è SOLUTION: Connect Google Calendar OR configure email settings in AI Assistant tab.';
    } else if (!hasEmailJS) {
        message += '‚ö†Ô∏è SOLUTION: Complete EmailJS setup in Settings ‚Üí AI Assistant ‚Üí Email Reminders.';
    } else {
        message += '‚úÖ READY: Both calendar and email reminders should work!';
    }
    
    alert(message);
}

/**
 * Debug Google Calendar connection manually
 */
function debugGoogleConnection() {
    console.log('üîç === GOOGLE CALENDAR CONNECTION DEBUG ===');
    
    if (window.app) {
        console.log('üß™ Testing connection restoration...');
        window.app.restoreGoogleConnection();
        
        setTimeout(() => {
            const savedEmail = localStorage.getItem('google_account_email');
            const savedToken = localStorage.getItem('google_access_token');
            
            alert(`üìä Google Calendar Debug:

üíæ SAVED DATA:
- Email: ${savedEmail || 'Not saved'}
- Token: ${savedToken ? 'Present' : 'Not saved'}

üîß UI UPDATE:
- Button updated: Check if button shows "(Connected)"
- Table updated: Check Connected Accounts table

Check browser console (F12) for detailed logs.`);
        }, 1000);
    } else {
        alert('‚ùå TaskFlow app not loaded yet. Wait and try again.');
    }
}

/**
 * Ensure token is valid and refresh if needed (TOKEN LIFECYCLE MANAGEMENT)
 */
async function ensureValidToken() {
    try {
        // Check if GAPI is loaded
        if (typeof gapi === 'undefined' || !gapi.client) {
            console.warn('‚ö†Ô∏è GAPI not loaded yet');
            throw new Error('API_NOT_LOADED: Google API not ready. Please refresh the page.');
        }
        
        const token = gapi.client.getToken();
        
        // No token at all - return error but don't throw (let calling function handle)
        if (!token) {
            console.log('‚ö†Ô∏è No token found, authentication required');
            throw new Error('TOKEN_MISSING: Please connect Google Calendar first');
        }
        
        // Check if token is expired or expiring soon (5 min buffer)
        const expiresAt = token.expires_at || (Date.now() + 60 * 60 * 1000);
        const bufferTime = 5 * 60 * 1000; // 5 minutes
        const now = Date.now();
        
        if (expiresAt < now + bufferTime) {
            console.log('üîÑ Token expired or expiring soon, requesting refresh...');
            const timeLeft = Math.round((expiresAt - now) / 1000 / 60);
            console.log(`‚è∞ Token expires in ${timeLeft} minutes`);
            
            // Request new token
            return new Promise((resolve, reject) => {
                if (!tokenClient) {
                    console.error('‚ùå TokenClient not available for refresh');
                    reject(new Error('TOKEN_REFRESH_FAILED: Token client not initialized'));
                    return;
                }
                
                tokenClient.callback = async (resp) => {
                    if (resp.error) {
                        console.error('‚ùå Token refresh error:', resp.error);
                        reject(new Error('TOKEN_REFRESH_FAILED: ' + resp.error));
                        return;
                    }
                    
                    // Save new token
                    const newToken = gapi.client.getToken();
                    if (newToken) {
                        if (!newToken.expires_at && newToken.expires_in) {
                            newToken.expires_at = Date.now() + (newToken.expires_in * 1000);
                        }
                        localStorage.setItem('google_access_token', JSON.stringify(newToken));
                        console.log('‚úÖ Token refreshed successfully');
                        
                        // Notify user silently (no modal popup)
                        if (window.app && window.app.showNotification) {
                            window.app.showNotification('üîÑ Calendar connection refreshed', 'info');
                        }
                    }
                    resolve(true);
                };
                
                // Request with empty prompt for silent refresh
                try {
                    tokenClient.requestAccessToken({ prompt: '' });
                } catch (reqError) {
                    console.error('‚ùå Token request failed:', reqError);
                    reject(new Error('TOKEN_REFRESH_FAILED: ' + reqError.message));
                }
            });
        }
        
        const timeLeft = Math.round((expiresAt - now) / 1000 / 60);
        console.log(`‚úÖ Token is valid (expires in ${timeLeft} minutes)`);
        return true;
    } catch (error) {
        console.error('‚ùå Token validation failed:', error);
        throw error;
    }
}

/**
 * TaskFlow integration - create event from task (WITH TOKEN VALIDATION)
 */
async function createGoogleCalendarEventSimple(task) {
    try {
        console.log('üìÖ Creating Google Calendar event for task:', task.title);
        
        // Check if Google API is loaded
        if (typeof gapi === 'undefined') {
            throw new Error('API_NOT_LOADED: Google API not loaded. Please refresh the page.');
        }
        
        if (!gapi.client) {
            throw new Error('API_NOT_INITIALIZED: Google API client not initialized. Please refresh the page.');
        }
        
        // CRITICAL: Ensure token is valid before proceeding
        try {
            await ensureValidToken();
        } catch (tokenError) {
            // If token validation fails, provide helpful error
            console.error('Token validation failed:', tokenError);
            if (tokenError.message.includes('TOKEN_MISSING')) {
                throw new Error('Please connect Google Calendar first (click "Connect Google Calendar" button)');
            }
            throw tokenError;
        }
        
        console.log('‚úÖ Google API checks passed');
        
        let startDateTime, endDateTime;
        
        if (task.dueDate && task.dueTime) {
            const dateTimeString = `${task.dueDate}T${task.dueTime}:00`;
            startDateTime = new Date(dateTimeString).toISOString();
            endDateTime = new Date(new Date(dateTimeString).getTime() + 60*60*1000).toISOString();
        } else if (task.dueDate) {
            const dateTimeString = `${task.dueDate}T09:00:00`;
            startDateTime = new Date(dateTimeString).toISOString();
            endDateTime = new Date(new Date(dateTimeString).getTime() + 60*60*1000).toISOString();
        } else {
            startDateTime = new Date().toISOString();
            endDateTime = new Date(Date.now() + 60*60*1000).toISOString();
        }

        console.log('üïí Event times:', { startDateTime, endDateTime });

        // Direct Google Calendar API call (same as working test)
        const event = {
            'summary': task.title,
            'description': task.description || 'Created by TaskFlow AI',
            'start': {
                'dateTime': startDateTime,
                'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone
            },
            'end': {
                'dateTime': endDateTime,
                'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone
            }
        };
        
        console.log('üìù Event object:', event);
        
        // Use direct REST API call (no need to load Calendar API)
        const result = await calendarAPICall('POST', '/calendars/primary/events', event);
        console.log('‚úÖ Event created successfully:', result.htmlLink);
        return result;
        
    } catch (err) {
        console.error('‚ùå Error creating event:', err);
        
        // Provide better error messages
        if (err.message && err.message.includes('TOKEN_')) {
            throw err; // Already formatted
        } else if (err.status === 401) {
            throw new Error('AUTH_EXPIRED: Google Calendar connection expired. Please reconnect.');
        } else if (err.status === 403) {
            throw new Error('PERMISSION_DENIED: No permission to create calendar events.');
        } else if (err.status === 404) {
            throw new Error('CALENDAR_NOT_FOUND: Calendar not found.');
        } else if (!navigator.onLine) {
            throw new Error('NETWORK_ERROR: No internet connection.');
        } else {
            throw new Error('EVENT_CREATE_FAILED: ' + (err.message || 'Unknown error'));
        }
    }
}

/**
 * Create event with retry mechanism for transient failures
 */
async function createGoogleCalendarEventWithRetry(task, maxRetries = 2) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            console.log(`üîÑ Attempt ${attempt}/${maxRetries} to create calendar event...`);
            return await createGoogleCalendarEventSimple(task);
        } catch (err) {
            lastError = err;
            console.warn(`‚ö†Ô∏è Attempt ${attempt} failed:`, err.message);
            
            // Don't retry on auth errors - user needs to reconnect
            if (err.message.includes('TOKEN_') || err.message.includes('AUTH_') || err.message.includes('PERMISSION_')) {
                throw err;
            }
            
            // Wait before retry (exponential backoff)
            if (attempt < maxRetries) {
                const waitTime = Math.min(1000 * Math.pow(2, attempt - 1), 3000);
                console.log(`‚è≥ Waiting ${waitTime}ms before retry...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }
    
    throw lastError;
}

// Update existing Google Calendar event (WITH TOKEN VALIDATION)
async function updateGoogleCalendarEvent(task) {
    try {
        console.log('üìÖ Updating Google Calendar event for task:', task.title);
        
        // Check if Google API is loaded
        if (typeof gapi === 'undefined' || !gapi.client) {
            throw new Error('API_NOT_LOADED: Google API not loaded');
        }
        
        // CRITICAL: Ensure token is valid
        await ensureValidToken();
        
        if (!task.calendarEventId) {
            throw new Error('Task has no associated calendar event ID');
        }
        
        console.log('‚úÖ Google API checks passed, updating event:', task.calendarEventId);
        
        // Calculate event times
        let startDateTime, endDateTime;
        
        if (task.dueDate && task.dueTime) {
            const dateTimeString = `${task.dueDate}T${task.dueTime}:00`;
            startDateTime = new Date(dateTimeString).toISOString();
            endDateTime = new Date(new Date(dateTimeString).getTime() + 60*60*1000).toISOString();
        } else if (task.dueDate) {
            const dateTimeString = `${task.dueDate}T09:00:00`;
            startDateTime = new Date(dateTimeString).toISOString();
            endDateTime = new Date(new Date(dateTimeString).getTime() + 60*60*1000).toISOString();
        } else {
            // If no due date, delete the calendar event instead
            console.log('‚ö†Ô∏è Task no longer has due date, deleting calendar event');
            await deleteGoogleCalendarEventByTask(task);
            task.calendarEventId = null;
            return null;
        }

        console.log('üïí Updated event times:', { startDateTime, endDateTime });

        // Updated event object
        const event = {
            'summary': task.title,
            'description': task.description || 'Created by TaskFlow',
            'start': {
                'dateTime': startDateTime,
                'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone
            },
            'end': {
                'dateTime': endDateTime,
                'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone
            }
        };
        
        console.log('üìù Updated event object:', event);
        
        // Use direct REST API call
        const result = await calendarAPICall('PUT', `/calendars/primary/events/${task.calendarEventId}`, event);
        console.log('‚úÖ Event updated successfully:', result.htmlLink);
        return result;
        
    } catch (err) {
        console.error('‚ùå Error updating event:', err);
        throw err;
    }
}

// Diagnostic function to check Google Calendar setup
function diagnoseGoogleCalendar() {
    console.log('üîç Diagnosing Google Calendar setup...');
    
    // Get email from localStorage first
    const savedEmail = localStorage.getItem('google_account_email');
    console.log('üìß Checking stored email:', savedEmail);
    
    const checks = {
        'Google API loaded': typeof gapi !== 'undefined',
        'Google Client available': typeof gapi !== 'undefined' && !!gapi.client,
        'Authentication token exists': false,
        'Token is valid': false,
        'Calendar API ready': false,
        'Saved token in localStorage': !!localStorage.getItem('google_access_token'),
        'Saved email in localStorage': !!savedEmail
    };
    
    if (typeof gapi !== 'undefined' && gapi.client) {
        try {
            const token = gapi.client.getToken();
            checks['Authentication token exists'] = !!token;
            
            if (token) {
                // Check if token is expired
                const now = Date.now();
                const expiresAt = token.expires_at;
                checks['Token is valid'] = !expiresAt || now < expiresAt;
                
                if (expiresAt) {
                    const timeLeft = Math.round((expiresAt - now) / 1000 / 60);
                    if (timeLeft > 0) {
                        console.log(`‚è∞ Token expires in ${timeLeft} minutes`);
                        checks['Token expiration'] = `${timeLeft} minutes remaining`;
                    } else {
                        console.log(`‚ö†Ô∏è Token expired ${Math.abs(timeLeft)} minutes ago`);
                        checks['Token expiration'] = `EXPIRED ${Math.abs(timeLeft)} minutes ago`;
                    }
                } else {
                    checks['Token expiration'] = 'Unknown (no expires_at)';
                }
            }
            
            // Calendar API check - we use REST API now, so just check if token is valid
            checks['Calendar API ready'] = 'Using REST API (no client library needed)';
        } catch (e) {
            console.error('Error checking authentication:', e);
        }
    }
    
    // Display results in console
    console.log('üìã Diagnostic Results:');
    for (const [check, result] of Object.entries(checks)) {
        console.log(`${result ? '‚úÖ' : '‚ùå'} ${check}: ${result}`);
    }
    
    // Display results in UI
    const diagnosticsDiv = document.getElementById('calendarDiagnostics');
    const tableBody = document.getElementById('diagnosticsTableBody');
    const recommendation = document.getElementById('diagnosticsRecommendation');
    
    if (diagnosticsDiv && tableBody) {
        // Clear previous results
        tableBody.innerHTML = '';
        
        // Populate table with check results
        for (const [check, result] of Object.entries(checks)) {
            const row = document.createElement('tr');
            const statusIcon = result ? '‚úÖ' : '‚ùå';
            const statusText = result ? 'OK' : 'FAILED';
            const statusClass = result ? 'status-ok' : 'status-error';
            
            let details = result ? 'Working correctly' : 'Not available';
            
            // Add specific details for some checks
            if (check === 'Token is valid' && typeof gapi !== 'undefined' && gapi.client) {
                try {
                    const token = gapi.client.getToken();
                    if (token && token.expires_at) {
                        const timeLeft = Math.round((token.expires_at - Date.now()) / 1000 / 60);
                        details = result ? `Expires in ${timeLeft} minutes` : 'Token expired';
                    }
                } catch (e) {
                    details = 'Error checking token';
                }
            }
            
            row.innerHTML = `
                <td style="color: #1e293b; padding: 8px 12px; font-weight: 500;">${check}</td>
                <td style="padding: 8px 12px;"><span style="color: ${result ? '#10b981' : '#ef4444'}; font-weight: bold;">${statusIcon} ${statusText}</span></td>
                <td style="color: #374151; font-size: 0.9em; padding: 8px 12px; font-weight: 500;">${details}</td>
            `;
            tableBody.appendChild(row);
        }
        
        // Show specific recommendations
        let recommendationText = '';
        let recommendationClass = 'info';
        
        if (!checks['Google API loaded']) {
            recommendationText = 'üîß <strong>Issue:</strong> Google API not loaded. Check if scripts are properly included.';
            recommendationClass = 'error';
        } else if (!checks['Authentication token exists']) {
            recommendationText = 'üîß <strong>Action needed:</strong> Click "Connect Google Calendar" above to authenticate.';
            recommendationClass = 'warning';
        } else if (!checks['Token is valid']) {
            recommendationText = 'üîß <strong>Action needed:</strong> Your session expired. Click "Reset & Reconnect" to refresh your connection.';
            recommendationClass = 'warning';
        } else if (!checks['Calendar API ready']) {
            recommendationText = 'üîß <strong>Issue:</strong> Calendar API not ready. Try refreshing the page.';
            recommendationClass = 'error';
        } else {
            recommendationText = '‚úÖ <strong>Success:</strong> All checks passed! Your calendar integration is working correctly.';
            recommendationClass = 'success';
        }
        
        if (recommendation) {
            recommendation.innerHTML = recommendationText;
            recommendation.style.display = 'block';
            recommendation.style.color = '#1e293b';
            recommendation.style.fontWeight = '500';
            recommendation.style.padding = '12px';
            recommendation.style.borderRadius = '6px';
            recommendation.style.border = '2px solid #e2e8f0';
            
            // Update colors based on recommendation type
            const styles = {
                'success': { backgroundColor: '#d1fae5', borderColor: '#10b981', color: '#064e3b' },
                'warning': { backgroundColor: '#fef3c7', borderColor: '#f59e0b', color: '#78350f' }, 
                'error': { backgroundColor: '#fee2e2', borderColor: '#ef4444', color: '#7f1d1d' },
                'info': { backgroundColor: '#e0e7ff', borderColor: '#6366f1', color: '#312e81' }
            };
            
            const style = styles[recommendationClass] || styles.info;
            recommendation.style.backgroundColor = style.backgroundColor;
            recommendation.style.borderColor = style.borderColor;
            recommendation.style.color = style.color;
        }
        
        diagnosticsDiv.style.display = 'block';
    }
    
    // Specific recommendations for console
    if (!checks['Google API loaded']) {
        console.log('üîß Google API not loaded. Check if scripts are properly included.');
    } else if (!checks['Authentication token exists']) {
        console.log('üîß Not authenticated. Click "Authorize Google Calendar" first.');
    } else if (!checks['Token is valid']) {
        console.log('üîß Token expired. Click "Authorize Google Calendar" to refresh.');
    } else if (!checks['Calendar API ready']) {
        console.log('üîß Calendar API not ready. Try refreshing the page.');
    } else {
        console.log('‚úÖ All checks passed! Calendar integration should work.');
    }
    
    return checks;
}

// Test function to create a calendar event (WITH RETRY)
async function testCreateCalendarEvent() {
    console.log('üß™ Testing calendar event creation...');
    
    const diagnostics = diagnoseGoogleCalendar();
    if (!diagnostics['Google API loaded'] || !diagnostics['Authentication token exists']) {
        console.error('‚ùå Prerequisites not met. Run diagnoseGoogleCalendar() for details.');
        alert('Prerequisites not met. Please connect Google Calendar first.');
        return false;
    }
    
    const testTask = {
        title: 'Test Event from TaskFlow v3.0',
        description: 'Test event with token validation and retry mechanism',
        dueDate: new Date().toISOString().split('T')[0], // Today
        dueTime: '14:00' // 2 PM
    };
    
    try {
        const result = await createGoogleCalendarEventWithRetry(testTask);
        console.log('‚úÖ Test event created successfully!', result);
        alert('‚úÖ Test event created successfully! Check your Google Calendar.');
        return true;
    } catch (err) {
        console.error('‚ùå Test event creation failed:', err);
        alert('‚ùå Test failed: ' + err.message);
        return false;
    }
}

// Make diagnostic and utility functions available globally
window.diagnoseGoogleCalendar = diagnoseGoogleCalendar;
window.testCreateCalendarEvent = testCreateCalendarEvent;
window.ensureValidToken = ensureValidToken; // Expose for manual testing

// Simple reset and reconnect function
function resetAndReconnect() {
    console.log('üîÑ Simple reset and reconnect...');
    
    // 1. Clear data
    localStorage.removeItem('google_access_token');
    localStorage.removeItem('google_account_email');
    
    // 2. Reset gapi token
    if (typeof gapi !== 'undefined' && gapi.client) {
        gapi.client.setToken(null);
    }
    
    // 3. Update UI
    const authorizeDiv = document.getElementById('authorize-div');
    const signoutDiv = document.getElementById('signout-div');
    if (authorizeDiv) authorizeDiv.style.display = 'block';
    if (signoutDiv) signoutDiv.style.display = 'none';
    
    // 4. Update TaskFlow
    if (window.app) {
        window.app.updateGoogleCalendarConnectedState(false);
        window.app.calendarAccounts = window.app.calendarAccounts.filter(acc => acc.provider !== 'google');
        window.app.saveCalendarAccounts();
        window.app.forceUpdateConnectedAccountsTable();
    }
    
    console.log('‚úÖ Reset complete, opening auth...');
    
    // 5. Just open the auth modal - that's it!
    setTimeout(() => {
        openGoogleAuthModal();
    }, 500);
}

// Complete Google Calendar reset function
function resetGoogleCalendar() {
    console.log('üîÑ Performing complete Google Calendar reset...');
    
    try {
        // 1. Clear all localStorage data
        localStorage.removeItem('google_access_token');
        localStorage.removeItem('google_account_email');
        console.log('üóëÔ∏è Cleared localStorage data');
        
        // 2. Reset gapi client if available
        if (typeof gapi !== 'undefined' && gapi.client) {
            gapi.client.setToken(null);
            console.log('üîÑ Reset gapi client token');
        }
        
        // 3. Update UI to disconnected state
        const authorizeDiv = document.getElementById('authorize-div');
        const signoutDiv = document.getElementById('signout-div');
        
        if (authorizeDiv) authorizeDiv.style.display = 'block';
        if (signoutDiv) signoutDiv.style.display = 'none';
        
        // 4. Update TaskFlow UI state
        if (window.app) {
            window.app.updateGoogleCalendarConnectedState(false);
            window.app.forceUpdateConnectedAccountsTable();
            window.app.calendarAccounts = window.app.calendarAccounts.filter(acc => acc.provider !== 'google');
            window.app.saveCalendarAccounts();
            console.log('üîÑ Updated TaskFlow UI state');
        }
        
        // 5. Show reset notification and start reconnection
        if (window.app && window.app.showNotification) {
            window.app.showNotification('Google Calendar reset. Starting reconnection...', 'info');
        }
        
        console.log('‚úÖ Google Calendar reset complete');
        
        // Auto-trigger reconnection after a short delay
        setTimeout(() => {
            if (typeof forceReconnectGoogleCalendar === 'function') {
                console.log('üîÑ Auto-starting reconnection...');
                forceReconnectGoogleCalendar();
            }
        }, 1000);
        
        return true;
        
    } catch (error) {
        console.error('‚ùå Error during reset:', error);
        return false;
    }
}

// Force reconnection function
async function forceReconnectGoogleCalendar() {
    console.log('üîÑ Forcing Google Calendar reconnection...');
    
    try {
        // First reset everything
        resetGoogleCalendar();
        
        // Wait a moment for reset to complete
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Check if Google APIs are ready
        if (typeof gapi === 'undefined' || !gapi.client) {
            console.error('‚ùå Google API not ready for reconnection');
            alert('Google API not ready. Please refresh the page and try again.');
            return false;
        }
        
        if (typeof tokenClient === 'undefined' || !tokenClient) {
            console.error('‚ùå Token client not ready for reconnection');
            alert('Google authentication not ready. Please refresh the page and try again.');
            return false;
        }
        
        // Simply trigger handleAuthClick which has its own callback
        console.log('üöÄ Triggering authentication...');
        handleAuthClick();
        
    } catch (error) {
        console.error('‚ùå Reconnection failed:', error);
        alert('Reconnection failed: ' + error.message);
        
        if (window.app && window.app.showNotification) {
            window.app.showNotification('Reconnection failed: ' + error.message, 'error');
        }
    }
}

// Test connection and update UI
async function testConnectionAndUpdateUI(email) {
    try {
        console.log('üß™ Testing connection...');
        
        // Test with calendar list API call
        const response = await gapi.client.calendar.calendarList.list({ maxResults: 1 });
        
        if (response.result) {
            console.log('‚úÖ Connection test passed!');
            
            // Update UI
            document.getElementById('authorize-div').style.display = 'none';
            document.getElementById('signout-div').style.display = 'block';
            
            // Close any modal that might be open
            const modal = document.getElementById('googleAuthModal');
            if (modal) {
                modal.style.display = 'none';
                console.log('üîí Closed Google auth modal');
            }
            
            // Update TaskFlow state
            if (window.app) {
                // Add/update account in calendarAccounts array
                const existingGoogleAccount = window.app.calendarAccounts.find(acc => acc.provider === 'google');
                if (!existingGoogleAccount) {
                    const newAccount = {
                        provider: 'google',
                        accountName: 'Primary Account',
                        email: email,
                        calendars: [], // Will be populated by fetchAndCacheCalendars
                        status: 'connected',
                        connectedAt: new Date().toISOString()
                    };
                    window.app.calendarAccounts.push(newAccount);
                    window.app.saveCalendarAccounts();
                    console.log('üíæ Added Google account to calendarAccounts array');
                }
                
                window.app.updateGoogleCalendarConnectedState(true);
                window.app.forceUpdateConnectedAccountsTable();
                
                // Fetch and populate calendars
                try {
                    await window.app.fetchAndCacheCalendars();
                    await window.app.forcePopulateCalendarDropdown();
                    console.log('üìÖ Calendars fetched and dropdown populated');
                } catch (calError) {
                    console.warn('‚ö†Ô∏è Could not fetch calendars, using fallback:', calError);
                    await window.app.forcePopulateCalendarDropdown(); // Will use fallback
                }
                
                window.app.showNotification(`Google Calendar connected successfully (${email})`, 'success');
            }
            
            // Test event creation
            setTimeout(() => {
                testCreateCalendarEvent();
            }, 2000);
            
        } else {
            throw new Error('Invalid API response');
        }
        
    } catch (error) {
        console.error('‚ùå Connection test failed:', error);
        resetGoogleCalendar();
        if (window.app) {
            window.app.showNotification('Connection test failed. Please try again.', 'error');
        }
    }
}

// Make reset functions available globally
window.resetGoogleCalendar = resetGoogleCalendar;
window.forceReconnectGoogleCalendar = forceReconnectGoogleCalendar;

// Delete Google Calendar Event by searching for matching task details
async function deleteGoogleCalendarEventByTask(task, calendarId = 'primary') {
    try {
        console.log('ÔøΩ Searching for calendar events matching task:', task.title);
        
        // Check if user is authenticated
        const token = gapi.client.getToken();
        if (!token) {
            console.warn('‚ö†Ô∏è User not authenticated, cannot delete calendar event');
            return false;
        }

        // Calculate time range to search for the event
        let timeMin, timeMax;
        if (task.dueDate) {
            // Search for events on the task's due date
            const dateStr = task.dueDate;
            timeMin = new Date(dateStr + 'T00:00:00').toISOString();
            timeMax = new Date(dateStr + 'T23:59:59').toISOString();
        } else {
            // If no due date, search today and tomorrow
            const today = new Date();
            timeMin = today.toISOString();
            const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);
            timeMax = tomorrow.toISOString();
        }

        console.log('ÔøΩ Searching calendar events between:', timeMin, 'and', timeMax);

        // Get calendar events in the time range
        const request = await gapi.client.calendar.events.list({
            'calendarId': calendarId,
            'timeMin': timeMin,
            'timeMax': timeMax,
            'singleEvents': true,
            'orderBy': 'startTime'
        });

        const events = request.result.items || [];
        console.log('üìã Found', events.length, 'calendar events in time range');

        // Search for events that match the task
        const matchingEvents = events.filter(event => {
            const summary = event.summary || '';
            const description = event.description || '';
            
            // Check if the event title matches the task title
            const titleMatch = summary.toLowerCase().includes(task.title.toLowerCase()) ||
                              task.title.toLowerCase().includes(summary.toLowerCase());
            
            // Also check if it was created by TaskFlow
            const taskFlowCreated = description.includes('Created by TaskFlow') ||
                                   description.includes('TaskFlow AI');
            
            console.log('ÔøΩ Checking event:', {
                summary: summary,
                titleMatch: titleMatch,
                taskFlowCreated: taskFlowCreated
            });
            
            return titleMatch || taskFlowCreated;
        });

        console.log('üéØ Found', matchingEvents.length, 'matching events');

        if (matchingEvents.length === 0) {
            console.log('‚ÑπÔ∏è No matching calendar events found for task:', task.title);
            return false;
        }

        // Delete all matching events
        let deletedCount = 0;
        for (const event of matchingEvents) {
            try {
                console.log('üóëÔ∏è Deleting calendar event:', event.summary, 'ID:', event.id);
                
                const deleteRequest = await gapi.client.calendar.events.delete({
                    'calendarId': calendarId,
                    'eventId': event.id
                });
                
                console.log('‚úÖ Successfully deleted calendar event:', event.summary);
                deletedCount++;
                
            } catch (deleteErr) {
                console.error('‚ùå Failed to delete event:', event.summary, deleteErr);
            }
        }

        console.log(`üéâ Deleted ${deletedCount} out of ${matchingEvents.length} matching calendar events`);
        return deletedCount > 0;
        
    } catch (err) {
        console.error('‚ùå Error searching/deleting calendar events:', err);
        return false;
    }
}

// Bulk delete calendar events for multiple tasks
async function deleteMultipleGoogleCalendarEvents(tasks) {
    try {
        console.log('üóëÔ∏è Bulk deleting calendar events for', tasks.length, 'tasks');
        
        const deletionPromises = tasks
            .filter(task => task.calendarEventId)
            .map(task => deleteGoogleCalendarEvent(task.calendarEventId));
        
        if (deletionPromises.length === 0) {
            console.log('‚ÑπÔ∏è No calendar events to delete');
            return { success: 0, failed: 0 };
        }
        
        const results = await Promise.allSettled(deletionPromises);
        const success = results.filter(result => result.status === 'fulfilled' && result.value).length;
        const failed = results.length - success;
        
        console.log(`‚úÖ Calendar event deletion complete: ${success} success, ${failed} failed`);
        return { success, failed };
        
    } catch (err) {
        console.error('‚ùå Error in bulk calendar event deletion:', err);
        return { success: 0, failed: tasks.filter(t => t.calendarEventId).length };
    }
}

// Test function for debugging calendar event deletion
async function testCalendarEventDeletion() {
    try {
        console.log('üß™ Testing calendar event deletion functionality...');
        
        // Check authentication
        if (!window.gapi || !gapi.client) {
            console.error('‚ùå Google API not loaded');
            return;
        }
        
        const token = gapi.client.getToken();
        if (!token) {
            console.error('‚ùå Not authenticated with Google Calendar');
            return;
        }
        
        console.log('‚úÖ Authentication check passed');
        
        // Get all tasks
        const tasks = window.app.tasks;
        console.log('üìã Total tasks:', tasks.length);
        
        if (tasks.length === 0) {
            console.log('‚ÑπÔ∏è No tasks to test with');
            return;
        }
        
        // Display task details
        tasks.forEach((task, index) => {
            console.log(`üìù Task ${index + 1}:`, {
                id: task.id,
                title: task.title,
                dueDate: task.dueDate,
                dueTime: task.dueTime
            });
        });
        
        console.log('üîß You can now test deletion by calling: testDeleteTaskCalendarEvents(taskIndex)');
        console.log('üìñ Example: testDeleteTaskCalendarEvents(0) to test deletion for first task');
        
    } catch (err) {
        console.error('‚ùå Error in test function:', err);
    }
}

// Test function to delete calendar events for a specific task
async function testDeleteTaskCalendarEvents(taskIndex) {
    try {
        const task = window.app.tasks[taskIndex];
        if (!task) {
            console.error('‚ùå Task not found at index:', taskIndex);
            return;
        }
        
        console.log('üß™ Testing calendar event deletion for task:', task.title);
        const result = await deleteGoogleCalendarEventByTask(task);
        console.log('üî• Test deletion result:', result);
        return result;
    } catch (err) {
        console.error('‚ùå Test deletion failed:', err);
        return false;
    }
}

// Make test functions available globally
window.testCalendarEventDeletion = testCalendarEventDeletion;
window.testDeleteTaskCalendarEvents = testDeleteTaskCalendarEvents;

// EXACT WORKING INITIALIZATION FROM googlecalendar/app.js
window.onload = function() {
    console.log('üöÄ Initializing Google Calendar (EXACT WORKING VERSION)...');
    
    let gapiLoaded = false;
    let gisLoaded = false;

    function checkBothLoaded() {
        if (gapiLoaded && gisLoaded) {
            console.log('‚úÖ Both APIs loaded, showing authorize button');
            document.getElementById('calendar-loading').style.display = 'none';
            
            // Check if user is already signed in
            const token = gapi.client.getToken();
            if (token !== null) {
                console.log('üîÑ User already connected, updating UI');
                document.getElementById('signout-div').style.display = 'block';
                document.getElementById('authorize-div').style.display = 'none';
                
                // Update TaskFlow UI immediately with FORCE methods
                setTimeout(async () => {
                    if (window.app) {
                        console.log('üîÑ Updating TaskFlow UI for existing connection');
                        window.app.updateGoogleCalendarConnectedState(true);
                        
                        // üî• FORCE UI UPDATES for existing connection
                        window.app.forceUpdateConnectedAccountsTable();
                        await window.app.forcePopulateCalendarDropdown();
                    }
                }, 500);
            } else {
                document.getElementById('authorize-div').style.display = 'block';
                document.getElementById('signout-div').style.display = 'none';
            }
            
            // Also trigger the app's connection restoration (extra safety)
            if (window.app && window.app.restoreGoogleConnection) {
                setTimeout(() => {
                    console.log('üîÑ Triggering app connection restoration from Google API load');
                    window.app.restoreGoogleConnection();
                }, 1000);
            }
        }
    }

    // BACKUP EVENT LISTENER FOR GOOGLE CALENDAR BUTTON
    setTimeout(() => {
        const connectBtn = document.getElementById('connectGoogleCalendar');
        if (connectBtn) {
            console.log('üîß Adding backup event listener to Google Calendar button');
            
            // Remove any existing listeners
            const newBtn = connectBtn.cloneNode(true);
            connectBtn.parentNode.replaceChild(newBtn, connectBtn);
            
            // Add our listener
            newBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('üî• BACKUP LISTENER: Button clicked!');
                openGoogleAuthModal();
                return false;
            });
            
            console.log('‚úÖ Backup event listener added successfully');
        } else {
            console.error('‚ùå Could not find Google Calendar button for backup listener');
        }
    }, 1000);

    // Load Google API (RESTORED TOKEN RECOVERY FROM v2.13)
    if (typeof gapi !== 'undefined') {
        gapi.load('client', async function() {
            try {
                console.log('üì¶ Initializing Google API client...');
                
                // Set API key (needed for some Calendar API discovery calls)
                gapi.client.setApiKey(API_KEY);
                console.log('‚úÖ API key set');
                
                console.log('‚ÑπÔ∏è Calendar operations use REST API with OAuth token');
                
                // Restore saved token if it exists AND is valid
                const savedToken = localStorage.getItem('google_access_token');
                console.log('üîç Checking for saved token...', savedToken ? 'Found' : 'Not found');
                if (savedToken) {
                    try {
                        const token = JSON.parse(savedToken);
                        console.log('üìù Parsed token:', token);
                        
                        // Check if token is expired
                        const now = Date.now();
                        const expiresAt = token.expires_at;
                        const isExpired = expiresAt && now > expiresAt;
                        
                        if (isExpired) {
                            console.log('‚è∞ Token expired, clearing...');
                            localStorage.removeItem('google_access_token');
                            localStorage.removeItem('google_account_email');
                        } else {
                            gapi.client.setToken(token);
                            console.log('üîÑ Restored valid Google access token from localStorage');
                            
                            // Load Calendar API now that we have a valid token
                            console.log('üì¶ Loading Calendar API v3 with restored token...');
                            try {
                                await gapi.client.load('calendar', 'v3');
                                console.log('‚úÖ Calendar API v3 loaded successfully');
                                
                                if (gapi.client.calendar && gapi.client.calendar.events) {
                                    console.log('‚úÖ Calendar API events ready');
                                }
                            } catch (calError) {
                                console.error('‚ùå Failed to load Calendar API:', calError);
                            }
                            
                            // Also load OAuth2 API
                            console.log('üì¶ Loading OAuth2 API v2...');
                            try {
                                await gapi.client.load('oauth2', 'v2');
                                console.log('‚úÖ OAuth2 API v2 loaded successfully');
                            } catch (oauthError) {
                                console.error('‚ùå Failed to load OAuth2 API:', oauthError);
                            }
                            
                            // Verify token was set
                            const verifyToken = gapi.client.getToken();
                            console.log('‚úÖ Token verification:', verifyToken ? 'Token is set' : 'Token NOT set');
                        }
                    } catch (error) {
                        console.error('‚ùå Failed to restore token:', error);
                        localStorage.removeItem('google_access_token');
                        localStorage.removeItem('google_account_email');
                    }
                } else {
                    console.log('‚ÑπÔ∏è No saved token found - user needs to authorize Calendar');
                }
                
                gapiInited = true;
                gapiLoaded = true;
                console.log('‚úÖ GAPI fully loaded and ready');
                checkBothLoaded();
            } catch (error) {
                console.error('‚ùå Failed to initialize Google API:', error);
                console.error('Error details:', error.message, error.stack);
            }
        });
    }

    // Load Google Identity Services with proper popup configuration
    if (typeof google !== 'undefined' && google.accounts) {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES,
            callback: '', // EMPTY - callbacks set individually
            ux_mode: 'popup', // Force popup mode to prevent redirect loops
            select_account: true, // Allow account selection
        });
        gisInited = true;
        gisLoaded = true;
        console.log('‚úÖ GIS loaded with popup configuration');
        checkBothLoaded();
    }
};

// Helper functions
function isGoogleCalendarReady() {
    return gapiInited && gisInited && gapi.client.getToken() !== null;
}

function openGoogleAuthModal() {
    console.log('üéØ Opening Google Calendar modal...');
    const modal = document.getElementById('googleAuthModal');
    if (modal) {
        modal.classList.add('show');
        modal.style.display = 'block';
        console.log('‚úÖ Modal opened successfully');
        
        // Also ensure the modal content is visible
        const modalContent = modal.querySelector('.modal-content');
        if (modalContent) {
            modalContent.style.transform = 'scale(1)';
        }
    } else {
        console.error('‚ùå Google Calendar modal not found!');
        alert('ERROR: Google Calendar modal not found!');
    }
}

function closeGoogleAuthModal() {
    const modal = document.getElementById('googleAuthModal');
    if (modal) {
        modal.classList.remove('show');
        modal.style.display = 'none';
        console.log('‚úÖ Modal closed');
    }
}
// TaskFlow v2.13 - AI-Powered Smart Calendar Integration (Simple & Working)
class TaskFlowEnhanced {
    constructor() {
        console.log('üöÄ TaskFlowEnhanced constructor called - JavaScript is working!');
        
        // Firebase integration
        this.firebaseUserId = null;
        this.useFirestore = false;
        
        // Initialize with default data immediately
        this.tasks = this.getStoredTasks();
        this.projects = this.getStoredProjects();
        this.tags = this.getStoredTags(); // NEW: Initialize tags
        this.userEmails = this.getStoredEmails();
        this.settings = JSON.parse(localStorage.getItem('taskflow_settings') || '{}');
        this.calendarAccounts = JSON.parse(localStorage.getItem('taskflow_calendar_accounts') || '[]');
        
        // AI and calendar reminder settings
        this.aiRemindersEnabled = this.settings.enableAIReminders !== false;
        this.defaultCalendarId = this.settings.defaultCalendar || null;

        // START IN BOARD VIEW (Priority Matrix)
        this.currentView = 'matrix';
        this.currentTheme = localStorage.getItem('taskflow_theme') || 'light';
        this.sidebarOpen = false;
        
        // Filter state
        this.activeFilters = {
            priority: '',
            tags: '',
            project: ''
        };
        this.currentMonth = new Date().getMonth();
        this.currentYear = new Date().getFullYear();

        // Safe calendar system initialization
        try {
            if (typeof IntelligentCalendarSystem !== 'undefined') {
                this.calendarSystem = new IntelligentCalendarSystem();
            } else {
                this.calendarSystem = null;
            }
        } catch (error) {
            console.log('Calendar system not available');
            this.calendarSystem = null;
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initializeApp());
        } else {
            this.initializeApp();
        }
        
        // Robust Google connection restoration with API readiness check
        this.waitForGoogleAPIAndRestore();
    }

    // Wait for Google API to be ready, then restore connection
    async waitForGoogleAPIAndRestore() {
        console.log('‚è≥ Waiting for Google API to be ready before restoring connection...');
        
        let attempts = 0;
        const maxAttempts = 30; // 15 seconds max wait
        
        const checkAndRestore = () => {
            attempts++;
            console.log(`üîç Attempt ${attempts}: Checking Google API readiness...`);
            
            if (typeof gapi !== 'undefined' && gapi.client) {
                console.log('‚úÖ Google API is ready, attempting connection restoration...');
                this.restoreGoogleConnection();
                return true;
            }
            
            if (attempts < maxAttempts) {
                setTimeout(checkAndRestore, 500);
            } else {
                console.warn('‚ö†Ô∏è Google API not ready after 15 seconds, skipping connection restoration');
            }
            
            return false;
        };
        
        // Start checking immediately
        setTimeout(checkAndRestore, 100);
    }

    // Initialize with Firebase after authentication
    async initWithFirestore(userId) {
        console.log('üî• Initializing Firebase for user:', userId);
        this.firebaseUserId = userId;
        this.useFirestore = true;
        
        try {
            // Check if this is first login - migrate localStorage data
            console.log('üì¶ Checking for existing tasks...');
            const existingTasks = await window.FirebaseManager.getTasks(userId);
            console.log('‚úÖ Existing tasks:', existingTasks.length);
            
            if (existingTasks.length === 0 && this.tasks.length > 0) {
                console.log('üì¶ Migrating localStorage data to Firestore...');
                await window.FirebaseManager.migrateToFirestore(userId, this.tasks, this.projects);
            }
            
            // Load data from Firestore
            console.log('üì• Loading tasks from Firestore...');
            this.tasks = await window.FirebaseManager.getTasks(userId);
            console.log('‚úÖ Loaded tasks:', this.tasks.length);
            
            console.log('üì• Loading projects from Firestore...');
            this.projects = await window.FirebaseManager.getProjects(userId);
            console.log('‚úÖ Loaded projects:', this.projects.length);
            
            // Set up real-time listeners
            console.log('üì° Setting up real-time listeners...');
            const app = this;
            window.FirebaseManager.listenToTasks(userId, (tasks) => {
                console.log('üì° Real-time task update received');
                app.tasks = tasks;
                if (window.app && window.app.render) {
                    window.app.tasks = tasks;
                    window.app.render();
                }
            });
            
            window.FirebaseManager.listenToProjects(userId, (projects) => {
                console.log('üì° Real-time project update received');
                app.projects = projects;
                if (window.app && window.app.render) {
                    window.app.projects = projects;
                    window.app.render();
                }
            });
            console.log('‚úÖ Real-time listeners set up');
            
            // Initial render
            console.log('üé® Rendering initial view...');
            if (window.app && window.app.render) {
                window.app.render();
            }
            
            console.log('‚úÖ Firebase initialization complete');
        } catch (error) {
            console.error('‚ùå Firebase initialization error:', error);
            console.error('Error details:', {
                message: error.message,
                code: error.code,
                stack: error.stack
            });
            alert('Error loading your data: ' + error.message + '\n\nPlease check the console (F12) for details.');
        }
    }

    // Simple Google Calendar connection restoration
    restoreGoogleConnection() {
        console.log('üîÑ Restoring Google Calendar connection...');
        
        // Check if Google API is ready
        if (typeof gapi === 'undefined' || !gapi.client) {
            console.warn('‚ö†Ô∏è Google API not ready, skipping restoration');
            return false;
        }
        
        const savedEmail = localStorage.getItem('google_account_email');
        const savedTokenStr = localStorage.getItem('google_access_token');
        
        if (savedEmail && savedTokenStr) {
            try {
                const savedToken = JSON.parse(savedTokenStr);
                
                // Check if token is expired
                if (savedToken.expires_at && Date.now() > savedToken.expires_at) {
                    console.warn('‚è∞ Saved token has expired, clearing...');
                    localStorage.removeItem('google_access_token');
                    localStorage.removeItem('google_account_email');
                    return false;
                }
                
                // ACTUALLY restore the token to gapi
                gapi.client.setToken(savedToken);
                console.log('‚úÖ Token restored to gapi.client');
                
                // Test the token by making a simple API call
                this.testRestoredConnection(savedEmail);
                
                return true;
                
            } catch (error) {
                console.error('‚ùå Failed to restore token:', error);
                // Clear invalid data
                localStorage.removeItem('google_access_token');
                localStorage.removeItem('google_account_email');
                return false;
            }
        }
        
        console.log('‚ö†Ô∏è No valid connection data found');
        return false;
    }

    // Test restored connection with a simple API call
    async testRestoredConnection(email) {
        try {
            console.log('üß™ Testing restored Google Calendar connection...');
            
            // Try to get calendar list to verify connection
            const response = await gapi.client.calendar.calendarList.list({
                maxResults: 1
            });
            
            if (response.result) {
                console.log('‚úÖ Connection test successful!');
                
                // Update UI to show connected state
                document.getElementById('authorize-div').style.display = 'none';
                document.getElementById('signout-div').style.display = 'block';
                
                this.updateGoogleCalendarConnectedState(true);
                this.forceUpdateConnectedAccountsTable();
                
                // Fetch and populate calendars  
                try {
                    await this.fetchAndCacheCalendars();
                    await this.forcePopulateCalendarDropdown();
                    console.log('üìÖ Calendars fetched and dropdown populated on restore');
                } catch (calError) {
                    console.warn('‚ö†Ô∏è Could not fetch calendars on restore, using fallback:', calError);
                    await this.forcePopulateCalendarDropdown(); // Will use fallback
                }
                
                this.showNotification(`Google Calendar reconnected (${email})`, 'success');
                
            } else {
                throw new Error('Invalid API response');
            }
            
        } catch (error) {
            console.error('‚ùå Connection test failed:', error);
            
            // Clear invalid token
            localStorage.removeItem('google_access_token');
            localStorage.removeItem('google_account_email');
            
            // Reset UI
            document.getElementById('authorize-div').style.display = 'block';
            document.getElementById('signout-div').style.display = 'none';
            
            this.showNotification('Google Calendar connection expired, please reconnect', 'warning');
        }
    }

    // Check for existing Google Calendar connection
    checkExistingGoogleConnection() {
        try {
            console.log('üîç Checking for existing Google Calendar connection...');
            
            // Check multiple ways to detect connection
            const hasToken = typeof gapi !== 'undefined' && gapi.client && gapi.client.getToken() !== null;
            const savedEmail = localStorage.getItem('google_account_email');
            const savedToken = localStorage.getItem('google_access_token');
            const signoutDivVisible = document.getElementById('google_signout_btn') && 
                                      document.getElementById('google_signout_btn').style.display !== 'none';
            
            console.log('üó∫ Connection status:', {
                hasToken,
                savedEmail,
                savedToken: !!savedToken,
                gapiExists: typeof gapi !== 'undefined',
                signoutVisible: signoutDivVisible
            });
            
            const isConnected = hasToken || signoutDivVisible || savedEmail || savedToken;
            
            if (isConnected) {
                console.log('‚úÖ Found existing Google Calendar connection! Updating UI...');
                
                // Ensure the Google account is in the calendarAccounts array
                const hasGoogleAccount = this.calendarAccounts.find(acc => acc.provider === 'google');
                if (!hasGoogleAccount && savedEmail) {
                    console.log('üìù Adding Google account to calendarAccounts array from localStorage...');
                    const googleAccount = {
                        provider: 'google',
                        accountName: 'Primary Account',
                        email: savedEmail,
                        calendars: [], // Will be populated by fetchAndCacheCalendars
                        status: 'connected',
                        connectedAt: new Date().toISOString()
                    };
                    this.calendarAccounts.push(googleAccount);
                    localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(this.calendarAccounts));
                    console.log('üíæ Saved Google account to calendarAccounts array during startup');
                }
                
                this.updateGoogleCalendarConnectedState(true);
                
                // Force update UI elements immediately
                setTimeout(() => {
                    this.forceUpdateConnectedAccountsTable();
                    this.forcePopulateCalendarDropdown();
                }, 100);
                
                return true;
            } else {
                console.log('‚ö†Ô∏è No existing Google Calendar connection found');
                this.updateGoogleCalendarConnectedState(false);
                return false;
            }
        } catch (error) {
            console.log('‚ùå Error checking Google Calendar connection:', error);
            this.updateGoogleCalendarConnectedState(false);
            return false;
        }
    }
    showGoogleAuthButton() {
        // Button is now directly functional in HTML - no complex setup needed
        console.log('‚úÖ Google Calendar button is ready');
    }
    
    // Force update the Connected Accounts table (IMPROVED - uses calendarAccounts array)
    forceUpdateConnectedAccountsTable() {
        console.log('üî• FORCE updating Connected Accounts table...');
        
        const tableBody = document.querySelector('#connectedAccountsTable tbody');
        if (!tableBody) {
            console.log('‚ùå Table body not found!');
            return;
        }
        
        // FIRST: Always check localStorage for immediate data
        const savedEmail = localStorage.getItem('google_account_email');
        const savedToken = localStorage.getItem('google_access_token');
        
        console.log('üìä Connection data found:', {
            savedEmail: !!savedEmail,
            savedToken: !!savedToken,
            calendarAccountsLength: this.calendarAccounts.length
        });
        
        // If we have localStorage data but no calendarAccounts, immediately migrate
        if ((savedEmail || savedToken) && !this.calendarAccounts.find(acc => acc.provider === 'google')) {
            console.log('üöÄ IMMEDIATE migration of localStorage to calendarAccounts...');
            const googleAccount = {
                provider: 'google',
                accountName: 'Primary Account',
                email: savedEmail || 'Connected Account',
                calendars: ['Primary Calendar'],
                status: 'connected',
                connectedAt: new Date().toISOString()
            };
            this.calendarAccounts.push(googleAccount);
            localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(this.calendarAccounts));
            console.log('‚úÖ Migrated localStorage data to calendarAccounts array');
        }
        
        // Check both the calendarAccounts array and fallback to localStorage
        const hasStoredAccounts = this.calendarAccounts && this.calendarAccounts.length > 0;
        
        // Show table if we have either stored accounts or fallback data
        if (!hasStoredAccounts && !savedEmail && !savedToken) {
            console.log('‚ö†Ô∏è No calendar accounts found');
            // Make sure the "no accounts" row is showing
            const noAccountsRow = tableBody.querySelector('.no-accounts');
            if (!noAccountsRow) {
                tableBody.innerHTML = `
                    <tr class="no-accounts">
                        <td colspan="6" class="text-center">
                            <i class="fas fa-calendar-plus" style="font-size: 2rem; color: var(--text-tertiary); margin-bottom: 1rem;"></i>
                            <p>No calendar accounts connected</p>
                            <p class="small">Connect your Google, Outlook, or Apple calendar to get started</p>
                        </td>
                    </tr>
                `;
            }
            return;
        }
        
        console.log('‚úÖ Updating table with calendar account data');
        
        // Always remove the "no accounts" row
        const noAccountsRow = tableBody.querySelector('.no-accounts');
        if (noAccountsRow) {
            noAccountsRow.remove();
            console.log('üóëÔ∏è Removed no-accounts row');
        }
        
        // Clear existing account rows
        tableBody.querySelectorAll('tr:not(.no-accounts)').forEach(row => row.remove());
        
        // Add accounts from calendarAccounts array
        if (hasStoredAccounts) {
            this.calendarAccounts.forEach(account => {
                const row = document.createElement('tr');
                row.setAttribute('data-provider', account.provider);
                row.innerHTML = `
                    <td>
                        <span class="provider-badge provider-${account.provider}">
                            <i class="fab fa-${account.provider}"></i> ${account.provider.charAt(0).toUpperCase() + account.provider.slice(1)}
                        </span>
                    </td>
                    <td>${account.accountName}</td>
                    <td>${account.email}</td>
                    <td>${this.formatCalendarList(account.calendars)}</td>
                    <td>
                        <span class="status-${account.status}">
                            <i class="fas fa-${account.status === 'connected' ? 'check-circle' : 'exclamation-circle'}"></i> ${account.status.charAt(0).toUpperCase() + account.status.slice(1)}
                        </span>
                    </td>
                    <td>
                        <div class="account-actions">
                            <button class="btn btn--secondary btn--small" onclick="window.app.disconnectCalendarAccount('${account.provider}')">
                                <i class="fas fa-sign-out-alt"></i> Disconnect
                            </button>
                        </div>
                    </td>
                `;
                tableBody.appendChild(row);
            });
            console.log(`‚úÖ Added ${this.calendarAccounts.length} accounts from calendarAccounts array`);
        } 
        // Fallback: Add Google Calendar row from localStorage if no array data
        else if (savedEmail || savedToken) {
            const googleRow = document.createElement('tr');
            googleRow.setAttribute('data-provider', 'google');
            googleRow.innerHTML = `
                <td>
                    <span class="provider-badge provider-google">
                        <i class="fab fa-google"></i> Google
                    </span>
                </td>
                <td>Primary Account</td>
                <td>${savedEmail || 'Connected Account'}</td>
                <td>Primary Calendar</td>
                <td>
                    <span class="status-connected">
                        <i class="fas fa-check-circle"></i> Connected
                    </span>
                </td>
                <td>
                    <div class="account-actions">
                        <button class="btn btn--secondary btn--small" onclick="handleSignoutClick()">
                            <i class="fas fa-sign-out-alt"></i> Disconnect
                        </button>
                    </div>
                </td>
            `;
            tableBody.appendChild(googleRow);
            console.log('‚úÖ Added Google Calendar row from localStorage fallback');
        }
    }
    
    // Force populate calendar dropdown (always works)
    // Helper method to format calendar list for display
    formatCalendarList(calendars) {
        if (!calendars) return 'No calendars';
        
        if (Array.isArray(calendars)) {
            if (calendars.length === 0) return 'No calendars';
            
            // Check if calendars are objects with name property (new format)
            if (calendars[0] && typeof calendars[0] === 'object' && calendars[0].name) {
                return calendars.map(cal => cal.name + (cal.primary ? ' (Primary)' : '')).join(', ');
            }
            
            // Legacy format (just strings)
            return calendars.join(', ');
        }
        
        return calendars.toString();
    }

    // Debug method for the refresh button
    async debugRefreshCalendars() {
        console.log('üîÑ Refreshing calendars from button click...');
        try {
            await this.fetchAndCacheCalendars();
            await this.forcePopulateCalendarDropdown();
            this.showNotification('Calendar list refreshed!', 'success');
        } catch (error) {
            console.error('‚ùå Error refreshing calendars:', error);
            this.showNotification('Failed to refresh calendars: ' + error.message, 'error');
        }
    }

    // Fetch calendars from Google API and cache them
    async fetchAndCacheCalendars() {
        console.log('üìû Fetching calendars from Google API...');
        
        if (typeof gapi === 'undefined' || !gapi.client || !gapi.client.getToken()) {
            throw new Error('Google API not ready or not authenticated');
        }
        
        try {
            // Use direct REST API call instead of gapi.client.calendar
            const token = gapi.client.getToken();
            const response = await fetch('https://www.googleapis.com/calendar/v3/users/me/calendarList', {
                headers: {
                    'Authorization': `Bearer ${token.access_token}`,
                    'Content-Type': 'application/json'
                }
            });
            
            if (!response.ok) {
                throw new Error(`Calendar API error: ${response.status} ${response.statusText}`);
            }
            
            const data = await response.json();
            const calendars = data.items || [];
            
            console.log('üìÖ Found', calendars.length, 'calendars:', calendars.map(c => c.summary));
            
            // Update the calendarAccounts array with actual calendar list
            const googleAccount = this.calendarAccounts.find(acc => acc.provider === 'google');
            if (googleAccount) {
                googleAccount.calendars = calendars.map(cal => ({
                    id: cal.id,
                    name: cal.summary,
                    primary: cal.primary || false,
                    accessRole: cal.accessRole
                }));
                
                // Save the updated calendar accounts
                this.saveCalendarAccounts();
                console.log('üíæ Cached', calendars.length, 'calendars to calendarAccounts');
            }
            
            return calendars;
        } catch (error) {
            console.error('‚ùå Error fetching calendars:', error);
            throw error;
        }
    }

    async forcePopulateCalendarDropdown() {
        console.log('üî• FORCE populating calendar dropdown...');
        
        const dropdown = document.getElementById('defaultCalendar');
        if (!dropdown) {
            console.log('‚ùå Calendar dropdown not found!');
            return;
        }
        
        try {
            // Clear and add default option
            dropdown.innerHTML = '<option value="">Select a calendar</option>';
            
            // First try to use cached calendars
            const googleAccount = this.calendarAccounts.find(acc => acc.provider === 'google');
            let calendars = [];
            
            if (googleAccount && googleAccount.calendars && Array.isArray(googleAccount.calendars) && googleAccount.calendars.length > 0) {
                // Use cached calendars if available
                calendars = googleAccount.calendars;
                console.log('ÔøΩ Using cached calendars:', calendars.length);
            } else if (typeof gapi !== 'undefined' && gapi.client && gapi.client.getToken()) {
                // Fetch fresh calendars if not cached
                console.log('üìû No cached calendars, fetching from API...');
                const freshCalendars = await this.fetchAndCacheCalendars();
                calendars = freshCalendars.map(cal => ({
                    id: cal.id,
                    name: cal.summary,
                    primary: cal.primary || false
                }));
            }
            
            if (calendars.length > 0) {
                console.log('üìÖ Populating dropdown with', calendars.length, 'calendars');
                
                // Add calendar options
                calendars.forEach(calendar => {
                    const option = document.createElement('option');
                    option.value = calendar.id;
                    option.textContent = calendar.name + (calendar.primary ? ' (Primary)' : '');
                    
                    if (calendar.primary) {
                        option.selected = true;
                        // Save as default
                        localStorage.setItem('default_calendar_id', calendar.id);
                    }
                    
                    dropdown.appendChild(option);
                });
                
                console.log('‚úÖ Calendar dropdown populated successfully!');
            } else {
                console.log('‚ö†Ô∏è No calendars available, adding fallback options');
                
                // Add fallback options
                const savedCalendarId = localStorage.getItem('default_calendar_id');
                dropdown.innerHTML = `
                    <option value="">Select a calendar</option>
                    <option value="primary" ${!savedCalendarId || savedCalendarId === 'primary' ? 'selected' : ''}>Primary Calendar</option>
                `;
            }
        } catch (error) {
            console.error('‚ùå Error loading calendars:', error);
            
            // Fallback options
            dropdown.innerHTML = `
                <option value="">Select a calendar</option>
                <option value="primary" selected>Primary Calendar</option>
            `;
        }
    }
    
    // Disconnect a calendar account
    disconnectCalendarAccount(provider) {
        console.log(`üîå Disconnecting ${provider} calendar account...`);
        
        if (provider === 'google') {
            // Use the comprehensive reset function for Google
            if (typeof resetGoogleCalendar === 'function') {
                resetGoogleCalendar();
                console.log('‚úÖ Google Calendar disconnected using reset function');
            } else {
                console.error('resetGoogleCalendar function not found');
                // Fallback to old method
                if (typeof handleSignoutClick === 'function') {
                    handleSignoutClick();
                }
            }
        } else {
            // For other providers, remove from calendarAccounts array
            this.calendarAccounts = this.calendarAccounts.filter(acc => acc.provider !== provider);
            localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(this.calendarAccounts));
            
            // Update UI
            this.forceUpdateConnectedAccountsTable();
            this.showNotification(`${provider.charAt(0).toUpperCase() + provider.slice(1)} calendar disconnected`, 'success');
        }
    }
    
    // ü§ñ AI REMINDER ANALYSIS SYSTEM
    analyzeTaskForReminder(task) {
        console.log('ü§ñ === AI ANALYSIS START ===');
        console.log('üìã Task input:', task);
        
        const now = new Date();
        const dueDate = task.dueDate ? new Date(task.dueDate + (task.dueTime ? `T${task.dueTime}` : 'T23:59')) : null;
        
        console.log('üìÖ Date analysis:', {
            now: now.toISOString(),
            taskDueDate: task.dueDate,
            taskDueTime: task.dueTime,
            parsedDueDate: dueDate ? dueDate.toISOString() : null
        });
        
        // Enhanced AI Analysis Criteria
        const criteria = {
            hasDueDate: !!task.dueDate,
            isUrgent: task.priority && task.priority.important && task.priority.immediate,
            isImportant: task.priority && task.priority.important,
            hasParticipants: task.description && task.description.toLowerCase().includes('meeting'),
            isWorkRelated: task.tags.some(tag => ['work', 'meeting', 'project', 'deadline'].includes(tag.toLowerCase())),
            dueSoon: dueDate && (dueDate - now) <= 24 * 60 * 60 * 1000, // Due within 24 hours
            hasTime: !!task.dueTime,
            // NEW: Detect reminder keywords in title/description
            hasReminderKeywords: this.hasReminderKeywords(task.title, task.description),
            isCallTask: this.isCallRelatedTask(task.title, task.description)
        };
        
        console.log('üîç Analysis criteria:', criteria);
        
        // AI Decision Logic with enhanced scoring
        let shouldSendReminder = false;
        let confidence = 0;
        let reason = '';
        
        console.log('üß† Starting decision logic...');
        
        if (criteria.hasReminderKeywords && criteria.hasDueDate) {
            shouldSendReminder = true;
            confidence = 95;
            reason = 'Task explicitly mentions reminder with due date';
            console.log('‚úÖ Decision: High confidence - Reminder keywords + due date');
        } else if (criteria.hasReminderKeywords) {
            shouldSendReminder = true;
            confidence = 85;
            reason = 'Task explicitly mentions reminder (consider adding due date)';
            console.log('‚úÖ Decision: High confidence - Reminder keywords only');
        } else if (criteria.isCallTask && criteria.hasDueDate) {
            shouldSendReminder = true;
            confidence = 90;
            reason = 'Call/meeting task with due date';
            console.log('‚úÖ Decision: High confidence - Call task + due date');
        } else if (criteria.isCallTask) {
            shouldSendReminder = true;
            confidence = 75;
            reason = 'Call/meeting task (consider adding due date/time)';
            console.log('‚ö†Ô∏è Decision: Medium confidence - Call task only');
        } else if (criteria.hasDueDate && criteria.isUrgent) {
            shouldSendReminder = true;
            confidence = 95;
            reason = 'Important & immediate task with due date';
            console.log('‚úÖ Decision: High confidence - Urgent + due date');
        } else if (criteria.hasDueDate && criteria.hasTime && criteria.isImportant) {
            shouldSendReminder = true;
            confidence = 90;
            reason = 'Important task with specific time';
            console.log('‚úÖ Decision: High confidence - Important + time');
        } else if (criteria.hasParticipants && criteria.hasDueDate) {
            shouldSendReminder = true;
            confidence = 85;
            reason = 'Meeting or collaborative task';
            console.log('‚úÖ Decision: High confidence - Meeting + due date');
        } else if (criteria.dueSoon && criteria.isWorkRelated) {
            shouldSendReminder = true;
            confidence = 80;
            reason = 'Work-related task due soon';
            console.log('‚ö†Ô∏è Decision: Medium confidence - Work task due soon');
        } else if (criteria.hasDueDate && criteria.hasTime) {
            shouldSendReminder = true;
            confidence = 70;
            reason = 'Task with specific date and time';
            console.log('‚ö†Ô∏è Decision: Medium confidence - Date + time');
        } else if (criteria.hasDueDate) {
            shouldSendReminder = false;
            confidence = 50;
            reason = 'Has due date but lacks urgency indicators';
            console.log('‚ùå Decision: Low confidence - Only due date');
        } else {
            shouldSendReminder = false;
            confidence = 10;
            reason = 'No clear reminder indicators found';
            console.log('‚ùå Decision: Very low confidence - No indicators');
        }
        
        const result = {
            shouldSendReminder,
            confidence,
            reason,
            criteria
        };
        
        console.log('üéØ FINAL AI RESULT:', result);
        console.log('ü§ñ === AI ANALYSIS END ===');
        
        return result;
    }
    
    // Helper function to detect reminder keywords
    hasReminderKeywords(title, description) {
        const text = `${title} ${description || ''}`.toLowerCase();
        console.log('üîç Checking reminder keywords in text:', text);
        
        const reminderKeywords = [
            'remind', 'reminder', 'remember', 'don\'t forget', 'call', 'phone',
            'contact', 'reach out', 'follow up', 'check in', 'schedule',
            'appointment', 'meeting', 'alert', 'notify'
        ];
        
        const found = reminderKeywords.filter(keyword => text.includes(keyword));
        console.log('üìù Found reminder keywords:', found);
        
        return found.length > 0;
    }
    
    // Helper function to detect call-related tasks
    isCallRelatedTask(title, description) {
        const text = `${title} ${description || ''}`.toLowerCase();
        console.log('üìû Checking call keywords in text:', text);
        
        const callKeywords = ['call', 'phone', 'ring', 'dial', 'contact', 'reach'];
        const found = callKeywords.filter(keyword => text.includes(keyword));
        console.log('üì± Found call keywords:', found);
        
        return found.length > 0;
    }
    
    // Check and process automatic reminders on system load
    async processAutomaticReminders() {
        console.log('ü§ñ AI: Analyzing tasks for automatic reminders...');
        
        const connectedEmail = localStorage.getItem('google_account_email');
        if (!connectedEmail) {
            console.log('‚ö†Ô∏è No connected calendar account found');
            return;
        }
        
        const tasksNeedingReminders = this.tasks.filter(task => {
            if (task.completed || task.reminderSent) return false;
            
            const analysis = this.analyzeTaskForReminder(task);
            return analysis.shouldSendReminder && analysis.confidence >= 70;
        });
        
        if (tasksNeedingReminders.length > 0) {
            console.log(`üéØ Found ${tasksNeedingReminders.length} tasks requiring reminders`);
            
            for (const task of tasksNeedingReminders) {
                await this.sendAutomaticReminder(task, connectedEmail);
            }
            
            this.showNotification(`AI sent ${tasksNeedingReminders.length} automatic calendar reminders`, 'success');
        }
    }
    
    // Send automatic reminder (Enhanced with Email + Calendar)
    async sendAutomaticReminder(task, email) {
        try {
            const analysis = this.analyzeTaskForReminder(task);
            console.log(`üìß Sending automatic reminder for: ${task.title}`);
            console.log(`üéØ AI Confidence: ${analysis.confidence}% - ${analysis.reason}`);
            
            const results = {
                calendar: null,
                email: null,
                success: false
            };
            
            // 1. Create Google Calendar event
            try {
                if (isGoogleCalendarReady()) {
                    results.calendar = await createGoogleCalendarEventWithRetry(task);
                    console.log('‚úÖ Calendar event created:', results.calendar.htmlLink);
                } else {
                    console.log('‚ö†Ô∏è Google Calendar not connected, skipping calendar event');
                }
            } catch (calendarError) {
                console.error('‚ùå Calendar event failed:', calendarError);
                results.calendar = { error: calendarError.message };
            }
            
            // 2. Send Email Reminder
            try {
                if (this.isEmailConfigured()) {
                    results.email = await this.sendEmailReminder(task, analysis);
                    console.log('‚úÖ Email reminder sent successfully');
                } else {
                    console.log('‚ö†Ô∏è Email not configured, skipping email reminder');
                }
            } catch (emailError) {
                console.error('‚ùå Email reminder failed:', emailError);
                results.email = { error: emailError.message };
            }
            
            // 3. Update task with reminder info
            task.reminderSent = true;
            task.reminderEmail = email;
            task.reminderSentAt = new Date().toISOString();
            task.aiReminderSuggested = true;
            
            if (results.calendar && !results.calendar.error) {
                task.calendarEventId = results.calendar.id;
            }
            
            results.success = true;
            this.saveTasks();
            
            // Show success notification
            this.showReminderSuccessNotification(task, results);
            
            console.log(`‚úÖ Automatic reminder completed for: ${task.title}`, results);
            return results;
            
        } catch (error) {
            console.error(`‚ùå Failed to send reminder for ${task.title}:`, error);
            throw error;
        }
    }
    
    // Initialize EmailJS service
    initializeEmailJS() {
        const publicKey = localStorage.getItem('emailjsPublicKey');
        if (typeof emailjs !== 'undefined' && publicKey) {
            emailjs.init(publicKey);
            console.log('üìß EmailJS initialized');
        }
    }
    
    // Check if email is properly configured
    isEmailConfigured() {
        const enableEmail = localStorage.getItem('enableEmailReminders') !== 'false';
        const userEmail = localStorage.getItem('userEmail');
        const serviceId = localStorage.getItem('emailjsServiceId');
        const templateId = localStorage.getItem('emailjsTemplateId');
        const publicKey = localStorage.getItem('emailjsPublicKey');
        
        const configured = enableEmail && userEmail && serviceId && templateId && publicKey;
        console.log('üìß Email configuration check:', {
            enableEmail, 
            hasUserEmail: !!userEmail,
            hasServiceId: !!serviceId,
            hasTemplateId: !!templateId,
            hasPublicKey: !!publicKey,
            configured
        });
        
        return configured;
    }
    
    // Send simple reminder (NO EmailJS complexity)
    async sendEmailReminder(task, analysis) {
        console.log('ÔøΩ === SIMPLE REMINDER START ===');
        
        const userEmail = localStorage.getItem('google_account_email');
        
        // Create a simple browser notification
        const dueDateTime = this.formatTaskDateTime(task);
        const notificationTitle = `üìÖ TaskFlow Reminder: ${task.title}`;
        const notificationBody = `Due: ${dueDateTime}\nPriority: ${this.formatPriority(task.priority)}`;
        
        // Show browser notification
        if ('Notification' in window) {
            if (Notification.permission === 'granted') {
                new Notification(notificationTitle, {
                    body: notificationBody,
                    icon: '/favicon.ico'
                });
            } else if (Notification.permission !== 'denied') {
                const permission = await Notification.requestPermission();
                if (permission === 'granted') {
                    new Notification(notificationTitle, {
                        body: notificationBody,
                        icon: '/favicon.ico'
                    });
                }
            }
        }
        
        // Simple alert
        alert(`‚úÖ Reminder Set!

üìã Task: ${task.title}
ÔøΩ Due: ${dueDateTime}
üîî Browser notification shown
üìß Connected to: ${userEmail || 'No email'}

Calendar event will be created separately.`);
        
        return {
            success: true,
            message: 'Simple notification sent',
            method: 'notification'
        };
    }
    
    // Format task date and time for display
    formatTaskDateTime(task) {
        if (!task.dueDate) return 'No due date';
        
        const date = new Date(task.dueDate);
        let formatted = date.toLocaleDateString();
        
        if (task.dueTime) {
            formatted += ` at ${task.dueTime}`;
        }
        
        return formatted;
    }
    
    // Format priority for display
    formatPriority(priority) {
        const priorityMap = {
            'important-immediate': 'Important & Immediate',
            'important-not-immediate': 'Important & Not Immediate',
            'immediate-not-important': 'Immediate & Not Important',
            'not-important-not-immediate': 'Not Important & Not Immediate'
        };
        return priorityMap[priority] || priority;
    }
    
    // Show success notification for reminders
    showReminderSuccessNotification(task, results) {
        console.log('üì¢ Showing reminder success notification');
        
        let message = `‚úÖ Task "${task.title}" created successfully!\n\n`;
        const notifications = [];
        
        // Calendar event status
        if (results.calendar && results.calendar.success) {
            notifications.push('üìÖ Calendar event: Created');
        } else if (results.calendar && results.calendar.error) {
            notifications.push('‚ùå Calendar event: Failed');
        }
        
        // Email reminder status
        if (results.email) {
            if (results.email.success) {
                if (results.email.method === 'email') {
                    const email = localStorage.getItem('userEmail') || localStorage.getItem('google_account_email');
                    notifications.push(`üìß Email reminder: Sent to ${email}`);
                } else {
                    notifications.push('ÔøΩ Browser notification: Shown (EmailJS not configured)');
                }
            } else {
                notifications.push('‚ùå Email reminder: Failed (using notification instead)');
            }
        }
        
        if (notifications.length > 0) {
            message += notifications.join('\n');
        }
        
        // Add helpful setup hint if EmailJS is not configured
        const emailConfigured = localStorage.getItem('emailjsServiceId') && 
                              localStorage.getItem('emailjsTemplateId') && 
                              localStorage.getItem('emailjsPublicKey');
        
        if (!emailConfigured) {
            message += `\n\nüí° Tip: To receive email reminders, configure EmailJS in Settings ‚Üí AI Assistant ‚Üí Email Reminders`;
        }
        
        // Show browser notification if permitted
        if ('Notification' in window && Notification.permission === 'granted') {
            new Notification('TaskFlow AI Reminder', {
                body: `Reminder set for: ${task.title}`,
                icon: '/favicon.ico'
            });
        }
        
        // Show alert with full details
        alert(message);
        console.log(message);
    }
    
    // Test email functionality
    async testEmailConfiguration() {
        try {
            console.log('üß™ Testing email configuration...');
            
            if (!this.isEmailConfigured()) {
                throw new Error('Email not properly configured. Please check all settings.');
            }
            
            const testTask = {
                title: 'Test Email Reminder',
                description: 'This is a test email to verify your reminder system is working correctly.',
                dueDate: new Date().toISOString().split('T')[0],
                dueTime: new Date().toTimeString().split(' ')[0].substring(0, 5),
                priority: 'important-immediate',
                tags: ['test', 'email'],
                project: 'Email Configuration Test'
            };
            
            const testAnalysis = {
                confidence: 100,
                reason: 'Test email verification',
                shouldSendReminder: true
            };
            
            await this.sendEmailReminder(testTask, testAnalysis);
            
            alert('‚úÖ Test email sent successfully!\n\nCheck your inbox for the reminder email.');
            return true;
            
        } catch (error) {
            console.error('‚ùå Test email failed:', error);
            alert(`‚ùå Test email failed:\n\n${error.message}\n\nPlease check your EmailJS configuration.`);
            return false;
        }
    }
    
    // Load email settings into form fields
    loadEmailSettings() {
        console.log('üìß Loading email settings...');
        
        const emailSettings = {
            'userEmail': '',
            'emailjsServiceId': '',
            'emailjsTemplateId': '',
            'emailjsPublicKey': '',
            'enableEmailReminders': 'true'
        };
        
        Object.entries(emailSettings).forEach(([key, defaultValue]) => {
            const element = document.getElementById(key);
            if (element) {
                const savedValue = localStorage.getItem(key) || defaultValue;
                if (element.type === 'checkbox') {
                    element.checked = savedValue === 'true';
                } else {
                    element.value = savedValue;
                }
            }
        });
        
        console.log('üìß Email settings loaded');
    }
    
    // Update AI reminder preview in real-time
    updateAIReminderPreview() {
        console.log('ü§ñ === AI PREVIEW UPDATE START ===');
        const preview = document.getElementById('aiReminderPreview');
        if (!preview) {
            console.log('‚ùå AI preview element not found');
            return;
        }
        
        // Get current form data
        const formData = this.getTaskFormData();
        console.log('üìù Form data:', formData);
        
        // Always show preview, even with empty title
        if (!formData.title.trim()) {
            console.log('‚ö†Ô∏è Empty title, showing default state');
            // Show default state
            const reasonElement = document.getElementById('aiReminderReason');
            const confidenceFill = document.getElementById('aiConfidenceFill');
            const confidenceText = document.getElementById('aiConfidenceText');
            const noteElement = document.getElementById('aiReminderNote');
            
            if (reasonElement) {
                reasonElement.textContent = 'Start typing to see AI analysis...';
                reasonElement.style.color = 'var(--text-secondary)';
            }
            if (confidenceFill) confidenceFill.style.width = '0%';
            if (confidenceText) confidenceText.textContent = '0%';
            if (noteElement) {
                noteElement.textContent = 'üí° AI will analyze your task as you type';
                noteElement.style.color = 'var(--text-secondary)';
            }
            
            preview.classList.add('show');
            return;
        }
        
        // Create temporary task object for analysis
        const tempTask = {
            title: formData.title,
            description: formData.description,
            priority: formData.priority,
            tags: formData.tags,
            dueDate: formData.dueDate,
            dueTime: formData.dueTime,
            completed: false
        };
        
        console.log('üìÑ Temp task for analysis:', tempTask);
        
        // Analyze with AI
        const analysis = this.analyzeTaskForReminder(tempTask);
        console.log('ü§ñ AI Analysis result:', analysis);
        
        // Update preview content
        const reasonElement = document.getElementById('aiReminderReason');
        const confidenceFill = document.getElementById('aiConfidenceFill');
        const confidenceText = document.getElementById('aiConfidenceText');
        const noteElement = document.getElementById('aiReminderNote');
        
        console.log('üéØ Found elements:', {
            reasonElement: !!reasonElement,
            confidenceFill: !!confidenceFill,
            confidenceText: !!confidenceText,
            noteElement: !!noteElement
        });
        
        if (analysis.shouldSendReminder) {
            if (reasonElement) {
                reasonElement.textContent = `‚úÖ ${analysis.reason}`;
                reasonElement.style.color = 'var(--secondary-color)';
                console.log('‚úÖ Updated reason element - SHOULD send reminder');
            }
            if (noteElement) {
                noteElement.textContent = 'üéØ AI will automatically send a calendar reminder for this task';
                noteElement.style.color = 'var(--secondary-color)';
            }
        } else {
            if (reasonElement) {
                if (analysis.confidence < 30) {
                    reasonElement.textContent = `‚ùå ${analysis.reason}`;
                    reasonElement.style.color = 'var(--error-color)';
                    console.log('‚ùå Updated reason element - LOW confidence');
                } else {
                    reasonElement.textContent = `‚ö†Ô∏è ${analysis.reason}`;
                    reasonElement.style.color = 'var(--warning-color)';
                    console.log('‚ö†Ô∏è Updated reason element - MEDIUM confidence');
                }
            }
            if (noteElement) {
                noteElement.textContent = 'üí° Add a due date/time or higher priority to trigger automatic reminders';
                noteElement.style.color = 'var(--text-secondary)';
            }
        }
        
        // Update confidence meter
        if (confidenceFill) {
            confidenceFill.style.width = `${analysis.confidence}%`;
            console.log(`üìà Updated confidence bar to ${analysis.confidence}%`);
        }
        if (confidenceText) {
            confidenceText.textContent = `${analysis.confidence}%`;
            console.log(`üìä Updated confidence text to ${analysis.confidence}%`);
        }
        
        // Color confidence bar based on level
        if (confidenceFill) {
            if (analysis.confidence >= 80) {
                confidenceFill.style.background = 'var(--secondary-color)';
            } else if (analysis.confidence >= 60) {
                confidenceFill.style.background = 'var(--warning-color)';
            } else {
                confidenceFill.style.background = 'var(--error-color)';
            }
        }
        
        // Show preview
        preview.classList.add('show');
        console.log(`üìà AI preview updated: ${analysis.confidence}% confidence - ${analysis.reason}`);
        console.log('ü§ñ === AI PREVIEW UPDATE END ===');
    }
    
    clearConnectedAccountsTable() {
        const tableBody = document.querySelector('#connectedAccountsTable tbody');
        if (!tableBody) return;
        
        // Remove Google Calendar row
        const googleRow = tableBody.querySelector('[data-provider="google"]');
        if (googleRow) {
            googleRow.remove();
        }
        
        // Add "no accounts" row if table is empty
        if (tableBody.children.length === 0) {
            const noAccountsRow = document.createElement('tr');
            noAccountsRow.className = 'no-accounts';
            noAccountsRow.innerHTML = `
                <td colspan="6" class="text-center">
                    <i class="fas fa-calendar-plus" style="font-size: 2rem; color: var(--text-tertiary); margin-bottom: 1rem;"></i>
                    <p>No calendar accounts connected</p>
                    <p class="small">Connect your Google, Outlook, or Apple calendar to get started</p>
                </td>
            `;
            tableBody.appendChild(noAccountsRow);
        }
    }
    
    updateGoogleCalendarConnectedState(connected) {
        console.log('üîß updateGoogleCalendarConnectedState called with:', connected);
        
        // Update the main Settings button
        const connectGoogleBtn = document.getElementById('connectGoogleCalendar');
        if (connectGoogleBtn) {
            if (connected) {
                console.log('‚úÖ Setting button to connected state');
                connectGoogleBtn.innerHTML = '<i class="fab fa-google"></i> Google Calendar (Connected)';
                connectGoogleBtn.style.backgroundColor = '#34d399';
            } else {
                console.log('‚ùå Setting button to disconnected state');
                connectGoogleBtn.innerHTML = '<i class="fab fa-google"></i> Connect Google Calendar';
                connectGoogleBtn.style.backgroundColor = '';
            }
        } else {
            console.log('‚ùå Connect Google Calendar button not found!');
        }
    }

    autoSetupGoogleCalendar(userEmail) {
        console.log('üîÑ Auto-setting up Google Calendar for:', userEmail);
        
        try {
            // Save email to localStorage
            localStorage.setItem('google_account_email', userEmail);
            
            // Add to calendar accounts if not already there
            const existingGoogleAccount = this.calendarAccounts.find(acc => acc.provider === 'google');
            if (!existingGoogleAccount) {
                const newAccount = {
                    provider: 'google',
                    accountName: 'Primary Account',
                    email: userEmail,
                    calendars: ['Primary Calendar'],
                    status: 'connected',
                    connectedAt: new Date().toISOString()
                };
                this.calendarAccounts.push(newAccount);
                localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(this.calendarAccounts));
                console.log('‚úÖ Google Calendar auto-connected');
            }
            
            // Update UI
            this.updateGoogleCalendarConnectedState(true);
            this.forceUpdateConnectedAccountsTable();
            this.showNotification('Google Calendar connected automatically!', 'success');
            
        } catch (error) {
            console.error('‚ùå Auto-setup failed:', error);
        }
    }

    
    showGoogleAuthModal() {
        console.log('üîç showGoogleAuthModal called');
        const modal = document.getElementById('googleAuthModal');
        if (modal) {
            modal.style.display = 'block';
        }
    }
    
    showGoogleAuthModal() {
        console.log('üîç showGoogleAuthModal called');
        const modal = document.getElementById('googleAuthModal');
        if (modal) {
            modal.style.display = 'block';
        }
    }
    
    hideGoogleAuthModal() {
        const modal = document.getElementById('googleAuthModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }    async createGoogleCalendarEvent(task) {
        try {
            console.log('üìÖ Creating Google Calendar event for task:', task.title);
            
            // Check if Google Calendar is connected using global function
            if (!isGoogleCalendarReady()) {
                console.log('‚ùå Google Calendar not ready');
                throw new Error('Google Calendar not connected');
            }
            
            // Use retry mechanism for reliability
            const result = await createGoogleCalendarEventWithRetry(task);
            
            // Update task with calendar event ID
            task.calendarEventId = result.id;
            task.calendarEventLink = result.htmlLink;
            
            // Save updated task
            this.saveTasks();
            
            console.log('‚úÖ Calendar event created successfully:', result.htmlLink);
            return result;
            
        } catch (error) {
            console.error('‚ùå Error creating calendar event:', error);
            throw error;
        }
    }

    handleGoogleSignOut() {
        try {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                
                // Remove Google accounts from connected accounts
                this.calendarAccounts = this.calendarAccounts.filter(account => account.provider !== 'google');
                this.saveCalendarAccounts();
                
                // Update UI
                this.updateConnectedAccountsTable();
                this.updateCalendarSelectors();
                
                this.showNotification('Google Calendar disconnected', 'success');
            }
        } catch (error) {
            console.error('Sign out failed:', error);
            this.showNotification('Failed to disconnect Google Calendar', 'error');
        }
    }

    // Helper method to check if Google Calendar is connected and ready
    isGoogleCalendarReady() {
        const ready = this.gapiInited && this.gisInited && gapi && gapi.client && gapi.client.getToken() !== null;
        console.log('üîç Google Calendar readiness check:', {
            gapiInited: this.gapiInited,
            gisInited: this.gisInited,
            gapiExists: typeof gapi !== 'undefined',
            hasToken: gapi && gapi.client ? gapi.client.getToken() !== null : false,
            overall: ready
        });
        return ready;
    }

    // AI-powered calendar reminder detection
    shouldCreateCalendarReminder(task) {
        console.log('ü§ñ AI analyzing task for calendar reminder:', task.title);
        console.log('üìä Task details:', {
            title: task.title,
            description: task.description,
            dueDate: task.dueDate,
            dueTime: task.dueTime,
            priority: task.priority
        });
        
        if (!this.aiRemindersEnabled) {
            console.log('‚ùå AI reminders disabled in settings');
            return false;
        }

        // Check if Google Calendar is ready
        const isReady = isGoogleCalendarReady();
        console.log('üìÖ Google Calendar ready status:', isReady);
        
        if (!isReady && !this.defaultCalendarId) {
            console.log('‚ùå No calendar connected and no default calendar set');
            return false;
        }

        const title = task.title.toLowerCase();
        const description = (task.description || '').toLowerCase();
        const combinedText = `${title} ${description}`;

        // AI logic to determine if reminder is needed
        const timeIndicators = [
            'meeting', 'appointment', 'call', 'interview', 'deadline',
            'due', 'submit', 'presentation', 'event', 'conference',
            'reminder', 'schedule', 'booking', 'reservation',
            'at ', 'pm', 'am', 'o\'clock', 'tomorrow', 'today',
            'monday', 'tuesday', 'wednesday', 'thursday', 'friday',
            'saturday', 'sunday', 'urgent', 'important'
        ];

        const urgencyIndicators = [
            'urgent', 'asap', 'critical', 'priority', 'important',
            'emergency', 'rush', 'immediate', 'must', 'need to'
        ];

        const collaborationIndicators = [
            'team', 'client', 'customer', 'meeting', 'discuss',
            'review', 'feedback', 'approval', 'sign off'
        ];

        // Check for time-sensitive keywords
        const hasTimeIndicator = timeIndicators.some(indicator => 
            combinedText.includes(indicator)
        );

        // Check for urgency
        const hasUrgencyIndicator = urgencyIndicators.some(indicator => 
            combinedText.includes(indicator)
        );

        // Check for collaboration
        const hasCollaborationIndicator = collaborationIndicators.some(indicator => 
            combinedText.includes(indicator)
        );

        // Check if task has a due date (higher likelihood of needing reminder)
        const hasDueDate = task.dueDate && task.dueTime;

        // Check priority level
        const isHighPriority = task.priority === 'urgent' || task.priority === 'high';

        // AI decision logic
        let score = 0;
        if (hasTimeIndicator) score += 3;
        if (hasUrgencyIndicator) score += 2;
        if (hasCollaborationIndicator) score += 2;
        if (hasDueDate) score += 3;
        if (isHighPriority) score += 2;
        if (task.title.length > 30) score += 1; // Detailed tasks often need reminders

        // Return true if score is 4 or higher
        const shouldCreate = score >= 4;
        
        console.log(`ü§ñ AI Calendar Reminder Analysis for "${task.title}":`);
        console.log(`   üìä Score: ${score}/12 (threshold: 4)`);
        console.log(`   ‚è∞ Time indicators: ${hasTimeIndicator}`);
        console.log(`   üö® Urgency indicators: ${hasUrgencyIndicator}`);
        console.log(`   üë• Collaboration indicators: ${hasCollaborationIndicator}`);
        console.log(`   üìÖ Has due date/time: ${hasDueDate}`);
        console.log(`   üî• High priority: ${isHighPriority}`);
        console.log(`   üìù Title length > 30: ${task.title.length > 30}`);
        console.log(`   üéØ Final Decision: ${shouldCreate ? '‚úÖ CREATE REMINDER' : '‚ùå no reminder needed'}`);

        return shouldCreate;
    }

    // Calendar event creation with comprehensive feedback
    async createCalendarEventWithFeedback(task, isAIRecommended = false) {
        console.log('üóìÔ∏è createCalendarEventWithFeedback called');
        console.log('üìä Parameters:', { task: task.title, isAIRecommended });
        
        try {
            // Check if we have necessary date/time info
            if (!task.dueDate) {
                console.log('‚ùå No due date - cannot create calendar event');
                this.showNotification('Calendar event needs a due date', 'warning');
                return;
            }
            
            console.log('üìÖ Task has due date:', task.dueDate);
            console.log('‚è∞ Task has due time:', task.dueTime || 'No time specified');
            
            // Show loading state
            const loadingMessage = isAIRecommended ? 
                'ü§ñ AI is creating a calendar reminder...' : 
                'üìÖ Creating calendar event...';
                
            console.log('üì¢ Showing notification:', loadingMessage);
            this.showNotification(loadingMessage, 'info');
            
            // Create the calendar event
            console.log('üöÄ Calling createGoogleCalendarEvent...');
            const calendarEvent = await this.createGoogleCalendarEvent(task);
            
            if (calendarEvent) {
                console.log('‚úÖ Calendar event created successfully!');
                console.log('üîó Event details:', {
                    id: calendarEvent.id,
                    link: calendarEvent.htmlLink,
                    summary: calendarEvent.summary
                });
                
                // Success notification with link
                const successMessage = isAIRecommended ? 
                    `ü§ñ AI created calendar reminder for "${task.title}"` : 
                    `üìÖ Calendar event created for "${task.title}"`;
                    
                console.log('üì¢ Showing success notification:', successMessage);
                this.showNotification(successMessage, 'success');
                
                // Show event link in console for easy access
                console.log('üåê Google Calendar Event URL:', calendarEvent.htmlLink);
                
            } else {
                console.log('‚ùå Calendar event creation returned null/undefined');
                throw new Error('Calendar event creation failed - no result returned');
            }
            
        } catch (error) {
            console.error('‚ùå Calendar event creation failed:', error);
            console.error('üí• Error details:', {
                message: error.message,
                stack: error.stack
            });
            
            const errorMessage = `Failed to create calendar event: ${error.message}`;
            console.log('üì¢ Showing error notification:', errorMessage);
            this.showNotification(errorMessage, 'error');
        }
    }

    updateConnectedAccountsTable() {
        const tbody = document.querySelector('#connectedAccountsTable tbody');
        if (!tbody) return;

        if (this.calendarAccounts.length === 0) {
            tbody.innerHTML = `
                <tr class="no-accounts">
                    <td colspan="6" class="text-center">
                        <i class="fas fa-calendar-plus" style="font-size: 2rem; color: var(--text-tertiary); margin-bottom: 1rem;"></i>
                        <p>No calendar accounts connected</p>
                        <p class="small">Connect your Google, Outlook, or Apple calendar to get started</p>
                    </td>
                </tr>
            `;
            return;
        }

        tbody.innerHTML = this.calendarAccounts.map(account => `
            <tr>
                <td>
                    <span class="provider-badge provider-${account.provider}">
                        <i class="fab fa-${account.provider}"></i>
                        ${account.provider.charAt(0).toUpperCase() + account.provider.slice(1)}
                    </span>
                </td>
                <td>${this.escapeHtml(account.displayName || account.name)}</td>
                <td>${this.escapeHtml(account.email)}</td>
                <td>${account.calendars ? account.calendars.length : 0} calendars</td>
                <td>
                    <span class="status-${account.status}">
                        <i class="fas fa-${account.status === 'connected' ? 'check-circle' : 'exclamation-triangle'}"></i>
                        ${account.status === 'connected' ? 'Connected' : 'Error'}
                    </span>
                </td>
                <td>
                    <div class="account-actions">
                        <button class="btn btn--small btn--secondary" onclick="app.refreshCalendarAccount('${account.id}')">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                        <button class="btn btn--small btn--danger" onclick="app.removeCalendarAccount('${account.id}')">
                            <i class="fas fa-trash"></i> Remove
                        </button>
                    </div>
                </td>
            </tr>
        `).join('');
    }

    async refreshCalendarAccount(accountId) {
        const account = this.calendarAccounts.find(acc => acc.id === accountId);
        if (!account) return;

        console.log('üîÑ Refreshing calendar account:', account.email);

        if (account.provider === 'google' && !account.isManual) {
            await this.fetchGoogleCalendars(account);
        }

        account.lastRefreshed = new Date().toISOString();
        this.saveCalendarAccounts();
        this.updateConnectedAccountsTable();
        this.updateCalendarSelectors();

        this.showNotification(`Calendar account ${account.email} refreshed`, 'success');
    }

    removeCalendarAccount(accountId) {
        const account = this.calendarAccounts.find(acc => acc.id === accountId);
        if (!account) return;

        if (confirm(`Remove calendar account ${account.email}?`)) {
            this.calendarAccounts = this.calendarAccounts.filter(acc => acc.id !== accountId);
            this.saveCalendarAccounts();
            this.updateConnectedAccountsTable();
            this.updateCalendarSelectors();

            this.showNotification(`Calendar account ${account.email} removed`, 'success');
        }
    }

    updateCalendarSelectors() {
        console.log('üîß updateCalendarSelectors called');
        console.log('üìä Current calendar accounts:', this.calendarAccounts);
        
        const eventCalendarSelect = document.getElementById('eventCalendar');
        const defaultCalendarSelect = document.getElementById('defaultCalendar');
        
        console.log('üîç Elements found:');
        console.log('  eventCalendar:', eventCalendarSelect ? 'Found' : 'NOT FOUND');
        console.log('  defaultCalendar:', defaultCalendarSelect ? 'Found' : 'NOT FOUND');

        let options = '<option value="">Select connected calendar</option>';
        let foundCalendars = 0;

        this.calendarAccounts.forEach((account, accountIndex) => {
            console.log(`üìã Account ${accountIndex}:`, {
                provider: account.provider,
                status: account.status,
                calendarsCount: account.calendars ? account.calendars.length : 0,
                email: account.email
            });
            
            if (account.status === 'connected' && account.calendars) {
                account.calendars.forEach((calendar, calIndex) => {
                    console.log(`  üìÖ Calendar ${calIndex}:`, {
                        id: calendar.id,
                        name: calendar.name,
                        primary: calendar.primary
                    });
                    
                    const displayName = calendar.primary ? 
                        `${calendar.name} (Primary)` : 
                        calendar.name;
                    options += `<option value="${calendar.id}" data-provider="${account.provider}">${displayName}</option>`;
                    foundCalendars++;
                });
            } else {
                console.log(`  ‚ö†Ô∏è Account skipped - Status: ${account.status}, Has calendars: ${!!account.calendars}`);
            }
        });

        console.log(`üìä Total calendars found: ${foundCalendars}`);
        console.log('üìù Generated options HTML:', options);

        if (eventCalendarSelect) {
            eventCalendarSelect.innerHTML = options;
            console.log('‚úÖ Updated eventCalendar selector');
        } else {
            console.log('‚ùå eventCalendar selector not found!');
        }
        
        if (defaultCalendarSelect) {
            const defaultOptions = '<option value="">Select default calendar</option>' + 
                options.replace('Select connected calendar', 'Select default calendar');
            defaultCalendarSelect.innerHTML = defaultOptions;
            console.log('‚úÖ Updated defaultCalendar selector with options:', defaultOptions);
            
            // Set current default if exists
            if (this.defaultCalendarId) {
                defaultCalendarSelect.value = this.defaultCalendarId;
                console.log('üéØ Set default calendar to:', this.defaultCalendarId);
            }
        } else {
            console.log('‚ùå defaultCalendar selector not found!');
        }
        
        // Force refresh the UI
        setTimeout(() => {
            if (defaultCalendarSelect) {
                const currentOptions = defaultCalendarSelect.innerHTML;
                console.log('üîÑ After timeout - defaultCalendar options:', currentOptions);
            }
        }, 100);
    }

    connectOutlookCalendar() {
        console.log('üîó Outlook Calendar connection coming soon...');
        this.showNotification('Outlook Calendar integration coming in next update!', 'info');
    }

    connectAppleCalendar() {
        console.log('üîó Apple Calendar connection coming soon...');
        this.showNotification('Apple Calendar integration coming in next update!', 'info');
    }

    // RECURRING EVENTS FUNCTIONALITY
    handleRecurrenceChange() {
        const recurrenceSelect = document.getElementById('taskRecurrence');
        const recurrenceEndGroup = document.getElementById('recurrenceEndGroup');

        if (recurrenceSelect && recurrenceEndGroup) {
            const isRecurring = recurrenceSelect.value !== 'none';
            recurrenceEndGroup.style.display = isRecurring ? 'block' : 'none';

            // Enable/disable end options based on radio selection
            const radioButtons = document.querySelectorAll('input[name="recurrenceEndType"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', () => {
                    const endDate = document.getElementById('recurrenceEndDate');
                    const endCount = document.getElementById('recurrenceCount');

                    endDate.disabled = radio.value !== 'date';
                    endCount.disabled = radio.value !== 'count';
                });
            });
        }
    }

    createRecurringTask(baseTask, recurrence) {
        const recurringTasks = [];
        const startDate = new Date(baseTask.dueDate);
        let currentDate = new Date(startDate);

        const endType = document.querySelector('input[name="recurrenceEndType"]:checked').value;
        const endDate = endType === 'date' ? new Date(document.getElementById('recurrenceEndDate').value) : null;
        const maxCount = endType === 'count' ? parseInt(document.getElementById('recurrenceCount').value) : 100;

        let count = 0;

        while (count < maxCount) {
            if (endDate && currentDate > endDate) break;

            const recurringTask = {
                ...baseTask,
                id: baseTask.id + '_recurring_' + count,
                dueDate: currentDate.toISOString().split('T')[0],
                isRecurring: true,
                recurringId: baseTask.id,
                recurringInstance: count,
                createdAt: new Date().toISOString()
            };

            recurringTasks.push(recurringTask);

            // Calculate next occurrence
            switch (recurrence) {
                case 'daily':
                    currentDate.setDate(currentDate.getDate() + 1);
                    break;
                case 'weekly':
                    currentDate.setDate(currentDate.getDate() + 7);
                    break;
                case 'monthly':
                    currentDate.setMonth(currentDate.getMonth() + 1);
                    break;
                case 'first-of-month':
                    currentDate.setMonth(currentDate.getMonth() + 1);
                    currentDate.setDate(1);
                    break;
                case 'last-of-month':
                    currentDate.setMonth(currentDate.getMonth() + 2);
                    currentDate.setDate(0);
                    break;
                case 'weekdays':
                    do {
                        currentDate.setDate(currentDate.getDate() + 1);
                    } while (currentDate.getDay() === 0 || currentDate.getDay() === 6);
                    break;
                default:
                    return recurringTasks;
            }

            count++;
        }

        return recurringTasks.slice(1); // Remove the first one as it's the original task
    }

    // REST OF THE CORE FUNCTIONALITY (keeping all existing methods)
    getStoredTasks() {
        let tasks = JSON.parse(localStorage.getItem('taskflow_tasks') || '[]');

        // Migration: Convert any string priorities to object priorities
        tasks = tasks.map(task => {
            if (task.priority && typeof task.priority === 'string') {
                console.log('üîÑ Migrating task priority from string to object:', task.title, task.priority);
                task.priority = this.convertPriorityToObject(task.priority);
            }
            return task;
        });

        if (tasks.length === 0) {
            const today = new Date().toISOString().split('T')[0];
            const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];

            tasks = [
                {
                    id: 'task_' + Date.now() + '_1',
                    title: 'Review project proposal',
                    description: 'Go through the Q4 project proposal and provide feedback',
                    priority: { important: true, immediate: true },
                    project: 'work',
                    tags: ['Review', 'Project'],
                    dueDate: today,
                    dueTime: '14:00',
                    completed: false,
                    createdAt: new Date().toISOString(),
                    calendarEvent: null
                },
                {
                    id: 'task_' + Date.now() + '_2',
                    title: 'Buy groceries',
                    description: 'Weekly shopping: milk, bread, eggs, fruits',
                    priority: { important: false, immediate: true },
                    project: 'personal',
                    tags: ['Shopping', 'Personal'],
                    dueDate: today,
                    dueTime: '18:00',
                    completed: false,
                    createdAt: new Date().toISOString(),
                    calendarEvent: null
                },
                {
                    id: 'task_' + Date.now() + '_3',
                    title: 'Setup meeting with team',
                    description: 'Schedule weekly team standup for project updates',
                    priority: { important: true, immediate: false },
                    project: 'work',
                    tags: ['Meeting', 'Team'],
                    dueDate: tomorrow,
                    dueTime: '10:00',
                    completed: false,
                    createdAt: new Date().toISOString(),
                    calendarEvent: null
                },
                {
                    id: 'task_' + Date.now() + '_4',
                    title: 'Plan weekend activity',
                    description: 'Research fun weekend activities for the family',
                    priority: { important: true, immediate: false },
                    project: 'personal',
                    tags: ['Family', 'Planning'],
                    dueDate: null,
                    dueTime: null,
                    completed: false,
                    createdAt: new Date().toISOString(),
                    calendarEvent: null
                },
                {
                    id: 'task_' + Date.now() + '_5',
                    title: 'Complete previous task',
                    description: 'This is an example of a completed task',
                    priority: { important: false, immediate: false },
                    project: 'work',
                    tags: ['Example'],
                    dueDate: today,
                    dueTime: '09:00',
                    completed: true,
                    createdAt: new Date().toISOString(),
                    completedAt: new Date().toISOString(),
                    calendarEvent: null
                }
            ];

            localStorage.setItem('taskflow_tasks', JSON.stringify(tasks));
        }

        return tasks;
    }

    getStoredProjects() {
        let projects = JSON.parse(localStorage.getItem('taskflow_projects') || '[]');

        // MIGRATION: Remove Shopping and Health from projects (they're now tags)
        projects = projects.filter(p => !['shopping', 'health'].includes(p.id));

        if (projects.length === 0) {
            projects = [
                { id: 'work', name: 'Work', color: '#3b82f6' },
                { id: 'personal', name: 'Personal', color: '#10b981' },
                { id: 'occ', name: 'OCC', color: '#8b5cf6' }
            ];
        }
        
        // Save cleaned projects back
        localStorage.setItem('taskflow_projects', JSON.stringify(projects));

        return projects;
    }

    getStoredTags() {
        let tags = JSON.parse(localStorage.getItem('taskflow_tags') || '[]');

        if (tags.length === 0) {
            tags = [
                { id: 'shopping', name: 'Shopping', color: '#f59e0b' },
                { id: 'health', name: 'Health', color: '#ef4444' },
                { id: 'urgent', name: 'Urgent', color: '#dc2626' },
                { id: 'important', name: 'Important', color: '#f97316' },
                { id: 'meeting', name: 'Meeting', color: '#0891b2' },
                { id: 'call', name: 'Call', color: '#059669' }
            ];
            localStorage.setItem('taskflow_tags', JSON.stringify(tags));
        }

        return tags;
    }

    getStoredEmails() {
        let emails = JSON.parse(localStorage.getItem('taskflow_user_emails') || '[]');

        if (emails.length === 0) {
            emails = [
                {
                    id: 'email_' + Date.now(),
                    email: 'your@gmail.com',
                    label: 'Personal Gmail',
                    addedAt: new Date().toISOString(),
                    isDefault: true
                }
            ];
            localStorage.setItem('taskflow_user_emails', JSON.stringify(emails));
        }

        return emails;
    }

    initializeApp() {
        console.log('üî• initializeApp called - starting initialization...');
        console.log('TaskFlow v2.19 initializing with', this.tasks.length, 'tasks...');
        console.log('ü§ñ AI-powered calendar reminders:', this.aiRemindersEnabled ? 'enabled' : 'disabled');
        console.log('üéØ Default view: Board View (Priority Matrix)');

        this.initializeTheme();
        this.initializeEventListeners();
        this.generateMiniCalendar();
        this.updateTaskCounts();
        this.updateStats();
        this.updateProjectsList();
        this.updateTagsList(); // NEW: Update tags list
        this.initializeSettingsEventListeners();
        
        // Initialize email reminder system
        this.initializeEmailJS();
        this.loadEmailSettings();

        // CRITICAL: Check for existing calendar connections after API initialization
        setTimeout(() => {
            console.log('üîç Checking for existing calendar connections during app initialization...');
            this.checkExistingGoogleConnection();
        }, 3000);
        
        // BACKUP: Additional checks to ensure connection is detected
        setTimeout(() => {
            console.log('üîÑ Backup connection check...');
            this.checkExistingGoogleConnection();
        }, 5000);
        
        setTimeout(() => {
            console.log('üîÑ Final connection check...');
            this.checkExistingGoogleConnection();
        }, 8000);

        // CRITICAL: Render tasks immediately in BOARD VIEW
        this.renderCurrentView();

        // ü§ñ AI: Process automatic reminders after a delay (allow Google APIs to load)
        setTimeout(() => {
            if (this.aiRemindersEnabled) {
                this.processAutomaticReminders();
            }
        }, 5000);

        console.log('‚úÖ TaskFlow v2.13 initialized successfully in Board View!');
        console.log('üìÖ Google Calendar button is ready to use in Settings');
        console.log('üìß Email reminder system ready');
    }

    // Simple helper - no complex setup needed anymore
    simpleGoogleCalendarHelper() {
        console.log('üìÖ Google Calendar helper ready');
    }

    initializeEventListeners() {
        console.log('üîß Initializing event listeners...');
        
        // All existing event listeners...
        // Hamburger menu
        const hamburgerBtn = document.getElementById('hamburgerBtn');
        const closeSidebar = document.getElementById('closeSidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');

        if (hamburgerBtn) {
            hamburgerBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.toggleSidebar();
            });
        }

        if (closeSidebar) {
            closeSidebar.addEventListener('click', () => this.toggleSidebar());
        }

        if (sidebarOverlay) {
            sidebarOverlay.addEventListener('click', () => this.toggleSidebar());
        }

        // Theme toggle
        const themeToggle = document.getElementById('themeToggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => this.toggleTheme());
        }

        // View switching
        document.querySelectorAll('.menu-item[data-view]').forEach(item => {
            item.addEventListener('click', (e) => {
                const view = e.target.closest('.menu-item').dataset.view;
                this.switchView(view);
            });
        });

        // Tool actions
        document.querySelectorAll('.menu-item[data-action]').forEach(item => {
            item.addEventListener('click', (e) => {
                const action = e.target.closest('.menu-item').dataset.action;
                this.handleToolAction(action);
            });
        });

        // Add task button
        const addTaskBtn = document.getElementById('addTaskBtn');

        console.log('üîç Add Task button found:', !!addTaskBtn);

        if (addTaskBtn) {
            console.log('‚úÖ Adding click listener to Add Task button');
            addTaskBtn.addEventListener('click', () => {
                console.log('üéØ Add Task button clicked!');
                this.showAddTaskModal();
            });
        } else {
            console.error('‚ùå Add Task button not found!');
        }

        // Add project button
        const addProjectBtn = document.getElementById('addProjectBtn');
        if (addProjectBtn) {
            addProjectBtn.addEventListener('click', () => this.showAddProjectModal());
        }

        // Add tag button  
        const addTagBtn = document.getElementById('addTagBtn');
        if (addTagBtn) {
            addTagBtn.addEventListener('click', () => this.showAddTagModal());
        }

        // Filter button
        const filterBtn = document.getElementById('filterBtn');
        if (filterBtn) {
            filterBtn.addEventListener('click', () => this.toggleFilterPanel());
        }

        // Filter inputs
        this.setupFilterListeners();

        // Clear filters button
        const clearFiltersBtn = document.getElementById('clearFiltersBtn');
        if (clearFiltersBtn) {
            clearFiltersBtn.addEventListener('click', () => {
                this.clearFilters();
            });
        }

        // Task form
        const taskForm = document.getElementById('taskForm');
        console.log('üîç Task form found:', !!taskForm);
        
        if (taskForm) {
            console.log('‚úÖ Adding submit listener to task form');
            taskForm.addEventListener('submit', (e) => {
                console.log('üéØ Form submitted! Preventing default and calling addTask()');
                e.preventDefault();
                this.addTask();
            });
        } else {
            console.error('‚ùå Task form not found!');
        }

        // üõ†Ô∏è BACKUP: Add direct click listener to Add Task button
        setTimeout(() => {
            const addTaskButton = document.querySelector('#taskForm button[type="submit"]');
            console.log('üîç Add Task button found:', !!addTaskButton);
            
            if (addTaskButton) {
                console.log('‚úÖ Adding backup click listener to Add Task button');
                addTaskButton.addEventListener('click', (e) => {
                    console.log('üéØ Add Task button clicked directly!');
                    if (!e.defaultPrevented) {
                        e.preventDefault();
                        this.addTask();
                    }
                });
            }
        }, 1000);

        // ü§ñ AI Natural Language Parsing for task title
        const taskTitleEl = document.getElementById('taskTitle');
        if (taskTitleEl) {
            let timeout;
            taskTitleEl.addEventListener('input', () => {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    if (taskTitleEl.value.length > 3) {
                        this.handleTitleNaturalLanguageParsing();
                    }
                }, 1000); // Wait 1 second after user stops typing
            });
        }

        // Modal controls
        const closeTaskModal = document.getElementById('closeTaskModal');
        const cancelTask = document.getElementById('cancelTask');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const closeGoogleAuthModal = document.getElementById('closeGoogleAuthModal');

        if (closeTaskModal) closeTaskModal.addEventListener('click', () => this.hideAddTaskModal());
        if (cancelTask) cancelTask.addEventListener('click', () => this.hideAddTaskModal());
        if (closeSettingsModal) closeSettingsModal.addEventListener('click', () => this.hideSettingsModal());
        if (closeGoogleAuthModal) closeGoogleAuthModal.addEventListener('click', () => this.hideGoogleAuthModal());

        // Email Settings
        const testEmailBtn = document.getElementById('testEmailButton');
        if (testEmailBtn) {
            testEmailBtn.addEventListener('click', () => this.testEmailConfiguration());
        }
        
        // Save email settings when changed
        const emailSettings = ['userEmail', 'emailjsServiceId', 'emailjsTemplateId', 'emailjsPublicKey', 'enableEmailReminders'];
        emailSettings.forEach(settingId => {
            const element = document.getElementById(settingId);
            if (element) {
                element.addEventListener('change', () => {
                    if (element.type === 'checkbox') {
                        localStorage.setItem(settingId, element.checked);
                    } else {
                        localStorage.setItem(settingId, element.value);
                    }
                    
                    // Reinitialize EmailJS if public key changed
                    if (settingId === 'emailjsPublicKey') {
                        this.initializeEmailJS();
                    }
                    
                    console.log(`üìß Email setting saved: ${settingId}`);
                });
            }
        });

        // Theme selection
        document.querySelectorAll('input[name="theme"]').forEach(input => {
            input.addEventListener('change', (e) => {
                this.setTheme(e.target.value);
            });
        });

        // Calendar navigation
        const prevMonth = document.getElementById('prevMonth');
        const nextMonth = document.getElementById('nextMonth');

        if (prevMonth) prevMonth.addEventListener('click', () => this.navigateCalendar(-1));
        if (nextMonth) nextMonth.addEventListener('click', () => this.navigateCalendar(1));

        // Calendar event checkbox
        const createCalendarEvent = document.getElementById('createCalendarEvent');
        if (createCalendarEvent) {
            createCalendarEvent.addEventListener('change', (e) => {
                const options = document.getElementById('calendarEventOptions');
                if (options) {
                    options.style.display = e.target.checked ? 'block' : 'none';
                }
            });
        }

        // Recurrence handling - NEW
        const taskRecurrence = document.getElementById('taskRecurrence');
        if (taskRecurrence) {
            taskRecurrence.addEventListener('change', () => this.handleRecurrenceChange());
        }

        // Note: AI preview listeners are set up when modal opens to ensure proper binding

        // Google Calendar modal listeners (simplified)
        const googleCalendarBtn = document.getElementById('googleCalendarBtn');
        if (googleCalendarBtn) {
            googleCalendarBtn.addEventListener('click', () => {
                this.showGoogleAuthModal();
            });
        }

        // Global modal close on outside click
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.classList.remove('show');
            }
        });

        // User dropdown menu
        const userProfile = document.querySelector('.user-profile');
        const userMenu = document.getElementById('userMenu');
        
        if (userProfile && userMenu) {
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!userProfile.contains(e.target) && !userMenu.contains(e.target)) {
                    userMenu.classList.remove('show');
                }
            });
        }

        // Task expanded modal listeners
        const taskExpandedModal = document.getElementById('taskExpandedModal');
        if (taskExpandedModal) {
            taskExpandedModal.addEventListener('click', (e) => {
                if (e.target === taskExpandedModal) {
                    this.closeExpandedTask();
                }
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Close expanded modal with Escape key
            if (e.key === 'Escape') {
                const expandedModal = document.getElementById('taskExpandedModal');
                if (expandedModal && expandedModal.classList.contains('show')) {
                    this.closeExpandedTask();
                }
            }
        });
    }

    initializeSettingsEventListeners() {
        // Calendar integration buttons
        const connectGoogleBtn = document.getElementById('connectGoogleCalendar');
        const connectOutlookBtn = document.getElementById('connectOutlookCalendar');
        const connectAppleBtn = document.getElementById('connectAppleCalendar');

        if (connectGoogleBtn) {
            connectGoogleBtn.addEventListener('click', () => this.showGoogleAuthModal());
        }
        if (connectOutlookBtn) {
            connectOutlookBtn.addEventListener('click', () => this.connectOutlookCalendar());
        }
        if (connectAppleBtn) {
            connectAppleBtn.addEventListener('click', () => this.connectAppleCalendar());
        }

        // Email Settings
        const testEmailBtn = document.getElementById('testEmailButton');
        if (testEmailBtn) {
            testEmailBtn.addEventListener('click', () => this.testEmailConfiguration());
        }
        
        // Save email settings when changed
        const emailSettings = ['userEmail', 'emailjsServiceId', 'emailjsTemplateId', 'emailjsPublicKey', 'enableEmailReminders'];
        emailSettings.forEach(settingId => {
            const element = document.getElementById(settingId);
            if (element) {
                element.addEventListener('change', () => {
                    if (element.type === 'checkbox') {
                        localStorage.setItem(settingId, element.checked);
                    } else {
                        localStorage.setItem(settingId, element.value);
                    }
                    
                    // Reinitialize EmailJS if public key changed
                    if (settingId === 'emailjsPublicKey') {
                        this.initializeEmailJS();
                    }
                    
                    console.log(`üìß Email setting saved: ${settingId}`);
                });
            }
        });

        // Settings tabs
        document.querySelectorAll('.settings-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                this.switchSettingsTab(e.target.dataset.tab);
            });
        });

        // Data management buttons (keeping existing functionality)
        const exportJSONBtn = document.getElementById('exportJSON');
        const exportCSVBtn = document.getElementById('exportCSV');
        const exportICSBtn = document.getElementById('exportICS');
        const importBtn = document.getElementById('importButton');
        const clearDataBtn = document.getElementById('clearAllData');
        const resetSettingsBtn = document.getElementById('resetSettings');

        if (exportJSONBtn) exportJSONBtn.addEventListener('click', () => this.exportData('json'));
        if (exportCSVBtn) exportCSVBtn.addEventListener('click', () => this.exportData('csv'));
        if (exportICSBtn) exportICSBtn.addEventListener('click', () => this.exportData('ics'));
        if (importBtn) importBtn.addEventListener('click', () => this.importData());
        if (clearDataBtn) clearDataBtn.addEventListener('click', () => this.clearAllData());
        if (resetSettingsBtn) resetSettingsBtn.addEventListener('click', () => this.resetAllSettings());
    }

    // ENHANCED TASK MANAGEMENT WITH RECURRING SUPPORT AND CALENDAR DEBUGGING
    addTask() {
        console.log('üöÄ addTask() method called!');
        
        const isEditing = !!this.editingTaskId;
        console.log(isEditing ? '‚úèÔ∏è Updating existing task...' : 'üéØ Adding new task...');

        const formData = this.getTaskFormData();
        if (!formData.title.trim()) {
            this.showNotification('Please enter a task title', 'error');
            return;
        }

        if (isEditing) {
            // Update existing task
            const taskIndex = this.tasks.findIndex(t => t.id === this.editingTaskId);
            if (taskIndex === -1) {
                this.showNotification('Task not found', 'error');
                return;
            }

            const existingTask = this.tasks[taskIndex];
            
            // Update task properties
            this.tasks[taskIndex] = {
                ...existingTask,
                title: formData.title,
                description: formData.description,
                priority: this.convertPriorityToObject(formData.priority), // Convert string to object
                project: formData.project,
                tags: formData.tags,
                dueDate: formData.dueDate,
                dueTime: formData.dueTime,
                recurrence: formData.recurrence,
                updatedAt: new Date().toISOString()
            };

            console.log('üìù Task updated:', this.tasks[taskIndex]);
            
            // üìÖ UPDATE CALENDAR EVENT IF IT EXISTS
            const updatedTask = this.tasks[taskIndex];
            if (updatedTask.calendarEventId) {
                console.log('üìÖ Updating existing calendar event:', updatedTask.calendarEventId);
                
                setTimeout(async () => {
                    try {
                        await updateGoogleCalendarEvent(updatedTask);
                        console.log('‚úÖ Calendar event updated successfully');
                        this.showNotification('üìÖ Calendar event updated!', 'success');
                    } catch (error) {
                        console.error('‚ùå Failed to update calendar event:', error);
                        this.showNotification('Task updated, but calendar sync failed', 'warning');
                    }
                }, 500);
            } else if (formData.dueDate) {
                // If task now has a date but no calendar event, create one
                const autoCalendarEnabled = document.getElementById('autoCreateEvents')?.checked ?? true;
                if (autoCalendarEnabled) {
                    console.log('üìÖ Task now has due date, creating calendar event');
                    
                    setTimeout(async () => {
                        try {
                            const result = await createGoogleCalendarEventWithRetry(updatedTask);
                            if (result) {
                                updatedTask.calendarEventId = result.id;
                                this.saveTasks();
                                this.showNotification('üìÖ Calendar event created!', 'success');
                            }
                        } catch (error) {
                            console.error('‚ùå Failed to create calendar event:', error);
                            this.showNotification('Calendar event failed: ' + error.message, 'warning');
                        }
                    }, 500);
                }
            }
            
            this.saveTasks();
            this.renderCurrentView();
            this.updateStats();
            this.hideAddTaskModal();
            this.resetTaskForm();
            
            // Clear editing state
            this.editingTaskId = null;
            
            this.showNotification(`Task "${formData.title}" updated successfully!`, 'success');
            return;
        }

        // Create new task
        const task = {
            id: 'task_' + Date.now(),
            title: formData.title,
            description: formData.description,
            priority: this.convertPriorityToObject(formData.priority), // Convert string to object
            project: formData.project,
            tags: formData.tags,
            dueDate: formData.dueDate,
            dueTime: formData.dueTime,
            recurrence: formData.recurrence,
            completed: false,
            createdAt: new Date().toISOString(),
            calendarEvent: null,
            // AI Reminder System Properties
            reminderSent: false,
            reminderEmail: null,
            reminderSentAt: null,
            aiReminderSuggested: false,
            calendarEventId: null
        };

        console.log('üìù Task created:', task);

        // Handle recurring tasks
        if (formData.recurrence && formData.recurrence !== 'none') {
            const recurringTasks = this.createRecurringTask(task, formData.recurrence);
            this.tasks.push(task, ...recurringTasks);
            console.log('‚úÖ Added task + recurring tasks. Total tasks now:', this.tasks.length);
            this.showNotification(`Created ${recurringTasks.length + 1} recurring tasks`, 'success');
        } else {
            this.tasks.push(task);
            console.log('‚úÖ Added single task. Total tasks now:', this.tasks.length);
            console.log('üìù Task added:', task.title, 'Priority:', task.priority);
        }

        // Save and update displays - REMOVED DUPLICATE RENDER CALLS
        console.log('üíæ Saving tasks and updating displays...');
        this.saveTasks();
        
        // Remove these duplicate calls - they conflict with renderCurrentView()
        // this.renderTasks();
        // this.renderPriorityMatrix();
        // this.updateTaskStats();

        // Show success notification first
        this.showNotification('Task created successfully!', 'success');

        // ü§ñ SIMPLE AUTO-CREATE CALENDAR EVENT
        const autoCalendarEnabled = document.getElementById('autoCreateEvents')?.checked ?? true;
        
        // Simple logic: If auto-create is enabled and task has a due date, create calendar event
        if (autoCalendarEnabled && task.dueDate) {
            console.log('üìÖ Auto-creating calendar event for:', task.title);
            
            setTimeout(async () => {
                try {
                    const result = await createGoogleCalendarEventWithRetry(task);
                    
                    if (result) {
                        console.log('‚úÖ Calendar event created:', result.htmlLink);
                        task.calendarEventId = result.id; // Store event ID for deletion later
                        this.saveTasks();
                        this.showNotification(`üìÖ Calendar event created!`, 'success');
                    }
                } catch (error) {
                    console.error('‚ùå Calendar event creation failed:', error);
                    // Show user-friendly error message
                    if (error.message.includes('TOKEN_')) {
                        this.showNotification(`‚ö†Ô∏è Calendar sync failed: Please reconnect Google Calendar`, 'warning');
                    } else if (!error.message.includes('not authenticated')) {
                        this.showNotification(`Calendar event failed: ${error.message}`, 'warning');
                    }
                }
            }, 500);
        } else {
            console.log('üìÖ Auto-calendar skipped - enabled:', autoCalendarEnabled, 'hasDate:', !!task.dueDate);
        }

        // üîç CALENDAR EVENT CREATION DEBUGGING
        console.log('='.repeat(50));
        console.log('üóìÔ∏è CALENDAR EVENT CREATION ANALYSIS');
        console.log('='.repeat(50));
        
        // Check for manual calendar event creation
        const createCalendarEvent = document.getElementById('createCalendarEvent');
        const manualCalendarRequested = createCalendarEvent && createCalendarEvent.checked;
        console.log('üìã Manual calendar event requested:', manualCalendarRequested);
        
        // AI-powered automatic calendar reminder detection
        const aiRecommendsReminder = this.shouldCreateCalendarReminder(task);
        console.log('ü§ñ AI recommends calendar reminder:', aiRecommendsReminder);
        
        // Final decision
        const shouldCreateEvent = manualCalendarRequested || aiRecommendsReminder;
        console.log('üéØ Final decision - Create calendar event:', shouldCreateEvent);
        
        if (shouldCreateEvent) {
            console.log('üìÖ Proceeding with calendar event creation...');
            this.createCalendarEventWithFeedback(task, aiRecommendsReminder && !manualCalendarRequested);
        } else {
            console.log('‚è≠Ô∏è Skipping calendar event creation');
            console.log('   Reasons:');
            console.log(`   - Manual request: ${manualCalendarRequested}`);
            console.log(`   - AI recommendation: ${aiRecommendsReminder}`);
        }
        
        console.log('='.repeat(50));
        console.log('üéØ TASK CREATION COMPLETE - UPDATING UI...');

        try {
            console.log('üíæ Saving tasks...');
            this.saveTasks();
            console.log('‚úÖ Tasks saved successfully');
            
            console.log('üîÑ Updating current view...');
            this.renderCurrentView();
            console.log('‚úÖ Current view updated');
            
            console.log('üìä Updating stats...');
            this.updateStats();
            console.log('‚úÖ Stats updated');
            
            console.log('üéØ Task creation complete - now closing modal...');
            this.hideAddTaskModal();
            
            console.log('üîÑ Resetting form...');
            this.resetTaskForm();
            console.log('‚úÖ Form reset');
            
            console.log('üéâ Showing success notification...');
            this.showNotification(`Task "${task.title}" added successfully!`, 'success');
            console.log('‚úÖ All task creation steps completed successfully!');
            
        } catch (error) {
            console.error('‚ùå ERROR during task creation UI update:', error);
            console.error('üí• Error stack:', error.stack);
            
            // Still try to close modal even if there's an error
            this.hideAddTaskModal();
            this.showNotification('Task created but there was an issue updating the display. Please refresh.', 'warning');
        }
    }

    // ü§ñ SIMPLE AI NATURAL LANGUAGE PARSING
    parseNaturalLanguage(text) {
        const result = {
            suggestedDate: '',
            suggestedTime: '',
            hasCalendarKeywords: false,
            confidence: 0
        };

        const lowercaseText = text.toLowerCase();
        
        // Check for calendar keywords
        const calendarKeywords = ['meeting', 'call', 'remind', 'appointment', 'schedule', 'deadline', 'email'];
        result.hasCalendarKeywords = calendarKeywords.some(keyword => lowercaseText.includes(keyword));

        // Helper: Convert word numbers to digits
        const wordToNumber = {
            'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
            'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10,
            'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15,
            'a': 1, 'an': 1
        };

        // ENHANCED DATE PARSING
        const now = new Date();
        const today = new Date(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()); // Use UTC date for consistency
        console.log('ü§ñ Date parsing - Today (UTC):', today.toISOString().split('T')[0], 'Text:', lowercaseText);
        
        // Pattern 1: "in X days" or "X days from now" (supports both digits and words)
        const inDaysPattern = /(?:in\s+)?(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|a|\d+)\s+days?(?:\s+from\s+now)?/i;
        const inDaysMatch = lowercaseText.match(inDaysPattern);
        if (inDaysMatch) {
            const daysInput = inDaysMatch[1].toLowerCase();
            const daysToAdd = wordToNumber[daysInput] || parseInt(daysInput);
            const targetDate = new Date(today);
            targetDate.setDate(today.getDate() + daysToAdd);
            result.suggestedDate = targetDate.toISOString().split('T')[0];
            result.confidence += 35;
            console.log(`ü§ñ Parsed "${daysInput} days":`, result.suggestedDate);
        }
        // Pattern 2: "tomorrow" - MUST check BEFORE other patterns
        else if (lowercaseText.includes('tomorrow')) {
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            result.suggestedDate = tomorrow.toISOString().split('T')[0];
            result.confidence += 30;
            console.log('ü§ñ Parsed "tomorrow":', result.suggestedDate, 'from today:', today.toISOString().split('T')[0]);
        }
        // Pattern 3: "today"
        else if (lowercaseText.includes('today')) {
            result.suggestedDate = today.toISOString().split('T')[0];
            result.confidence += 30;
            console.log('ü§ñ Parsed "today":', result.suggestedDate);
        }
        // Pattern 4: "next week" or "next week same day"
        else if (lowercaseText.match(/next\s+week/)) {
            const nextWeek = new Date(today);
            nextWeek.setDate(today.getDate() + 7);
            result.suggestedDate = nextWeek.toISOString().split('T')[0];
            result.confidence += 30;
            console.log('ü§ñ Parsed "next week":', result.suggestedDate);
        }
        // Pattern 5: "in a week" or "in 1 week"
        else if (lowercaseText.match(/in\s+(?:a|1)\s+week/)) {
            const nextWeek = new Date(today);
            nextWeek.setDate(today.getDate() + 7);
            result.suggestedDate = nextWeek.toISOString().split('T')[0];
            result.confidence += 30;
        }
        // Pattern 6: "in X weeks" (supports both digits and words)
        else if (lowercaseText.match(/in\s+(one|two|three|four|a|\d+)\s+weeks?/i)) {
            const weeksMatch = lowercaseText.match(/in\s+(one|two|three|four|a|\d+)\s+weeks?/i);
            const weeksInput = weeksMatch[1].toLowerCase();
            const weeksToAdd = wordToNumber[weeksInput] || parseInt(weeksInput);
            const targetDate = new Date(today);
            targetDate.setDate(today.getDate() + (weeksToAdd * 7));
            result.suggestedDate = targetDate.toISOString().split('T')[0];
            result.confidence += 30;
            console.log(`ü§ñ Parsed "${weeksInput} weeks":`, result.suggestedDate);
        }
        // Pattern 7: Specific day names (next monday, tuesday, etc.)
        else {
            const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            const nextDayMatch = lowercaseText.match(/(?:next\s+)?(monday|tuesday|wednesday|thursday|friday|saturday|sunday)/);
            
            if (nextDayMatch) {
                const targetDayName = nextDayMatch[1];
                const targetDayIndex = dayNames.indexOf(targetDayName);
                const currentDayIndex = today.getDay();
                
                // Calculate days until target day
                let daysUntil = targetDayIndex - currentDayIndex;
                if (daysUntil <= 0) {
                    daysUntil += 7; // Move to next week if day has passed or is today
                }
                
                const targetDate = new Date(today);
                targetDate.setDate(today.getDate() + daysUntil);
                result.suggestedDate = targetDate.toISOString().split('T')[0];
                result.confidence += 35;
                console.log(`ü§ñ Parsed "next ${targetDayName}":`, result.suggestedDate);
            }
        }

        // Enhanced time parsing - supports 10:30am format
        const timePatterns = [
            // Pattern 1: "10:30am" or "10:30pm" 
            { pattern: /(?:at\s+)?(\d{1,2}):(\d{2})\s*(am|pm)/i, hoursIdx: 1, minutesIdx: 2, ampmIdx: 3 },
            // Pattern 2: "10am" or "10pm" 
            { pattern: /(?:at\s+)?(\d{1,2})\s*(am|pm)/i, hoursIdx: 1, minutesIdx: null, ampmIdx: 2 },
            // Pattern 3: "10:30" (24-hour format)
            { pattern: /(?:at\s+)?(\d{1,2}):(\d{2})(?!\s*[ap]m)/i, hoursIdx: 1, minutesIdx: 2, ampmIdx: null }
        ];

        for (const timePattern of timePatterns) {
            const match = text.match(timePattern.pattern);
            if (match) {
                console.log('ü§ñ Time match found:', match);
                
                let hours = parseInt(match[timePattern.hoursIdx]);
                const minutes = timePattern.minutesIdx ? parseInt(match[timePattern.minutesIdx]) : 0;
                const ampm = timePattern.ampmIdx ? match[timePattern.ampmIdx] : null;

                console.log('ü§ñ Parsed time components:', { hours, minutes, ampm });

                // Convert to 24-hour format
                if (ampm) {
                    if (ampm.toLowerCase() === 'pm' && hours !== 12) {
                        hours += 12;
                    } else if (ampm.toLowerCase() === 'am' && hours === 12) {
                        hours = 0;
                    }
                }

                result.suggestedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                result.confidence += 40;
                console.log('ü§ñ ‚úÖ Final suggested time:', result.suggestedTime);
                break;
            }
        }

        // Boost confidence for calendar keywords
        if (result.hasCalendarKeywords) {
            result.confidence += 20;
        }

        return result;
    }

    // Auto-fill form based on AI parsing
    handleTitleNaturalLanguageParsing() {
        const titleEl = document.getElementById('taskTitle');
        if (!titleEl || !titleEl.value) return;

        console.log('ü§ñ Parsing title:', titleEl.value);
        const parsed = this.parseNaturalLanguage(titleEl.value);
        console.log('ü§ñ AI Parsing result:', parsed);

        // Auto-fill date if detected (allow updating for edits)
        if (parsed.suggestedDate) {
            const dateEl = document.getElementById('taskDate');
            if (dateEl) {
                // Update date even if it already has a value (for editing tasks)
                dateEl.value = parsed.suggestedDate;
                console.log('ü§ñ ‚úÖ Auto-filled/updated date:', parsed.suggestedDate);
            }
        }

        // Auto-fill time if detected (allow updating for edits)
        if (parsed.suggestedTime) {
            const timeEl = document.getElementById('taskTime');
            if (timeEl) {
                // Update time even if it already has a value (for editing tasks)
                timeEl.value = parsed.suggestedTime;
                console.log('ü§ñ ‚úÖ Auto-filled/updated time:', parsed.suggestedTime);
            }
        }

        // Show hint if calendar keywords detected
        if (parsed.hasCalendarKeywords && parsed.confidence > 30) {
            this.showNotification('ü§ñ AI detected this might need a calendar event!', 'info');
        }
    }

    getTaskFormData() {
        const titleEl = document.getElementById('taskTitle');
        const descEl = document.getElementById('taskDescription');
        const projectEl = document.getElementById('taskProject');
        const tagsEl = document.getElementById('taskTags');
        const dateEl = document.getElementById('taskDate');
        const timeEl = document.getElementById('taskTime');
        const recurrenceEl = document.getElementById('taskRecurrence');

        return {
            title: titleEl ? titleEl.value.trim() : '',
            description: descEl ? descEl.value.trim() : '',
            priority: this.getSelectedPriority(),
            project: projectEl ? projectEl.value : '',
            tags: tagsEl ? tagsEl.value.split(',').map(tag => tag.trim()).filter(tag => tag) : [],
            dueDate: dateEl ? dateEl.value : '',
            dueTime: timeEl ? timeEl.value : '',
            recurrence: recurrenceEl ? recurrenceEl.value : 'none'
        };
    }

    // Keep all existing functionality methods...
    // (Including theme management, view switching, task rendering, etc.)

    initializeTheme() {
        document.body.setAttribute('data-theme', this.currentTheme);
        this.updateThemeToggleIcon();
    }

    updateThemeToggleIcon() {
        const icon = document.querySelector('#themeToggle i');
        if (icon) {
            icon.className = this.currentTheme === 'light' ? 'fas fa-moon' : 'fas fa-sun';
        }
    }

    toggleSidebar() {
        this.sidebarOpen = !this.sidebarOpen;
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('sidebarOverlay');

        if (sidebar && overlay) {
            if (this.sidebarOpen) {
                sidebar.classList.add('open');
                overlay.classList.add('active');
                document.body.style.overflow = 'hidden';
            } else {
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
                document.body.style.overflow = '';
            }
        }
    }

    toggleTheme() {
        this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
        this.setTheme(this.currentTheme);
    }

    setTheme(theme) {
        this.currentTheme = theme;
        document.body.setAttribute('data-theme', theme);
        localStorage.setItem('taskflow_theme', theme);
        this.updateThemeToggleIcon();

        const themeInput = document.querySelector(`input[name="theme"][value="${theme}"]`);
        if (themeInput) {
            themeInput.checked = true;
        }
    }

    switchView(viewName) {
        this.currentView = viewName;

        document.querySelectorAll('.menu-item').forEach(item => {
            item.classList.remove('active');
        });

        const viewElement = document.querySelector(`[data-view="${viewName}"]`);
        if (viewElement) {
            viewElement.classList.add('active');
        }

        this.updateViewTitle(viewName);
        this.renderCurrentView();

        if (window.innerWidth < 768 && this.sidebarOpen) {
            this.toggleSidebar();
        }
    }

    updateViewTitle(viewName) {
        const titles = {
            today: 'Today',
            upcoming: 'Upcoming', 
            all: 'All Tasks',
            matrix: 'Priority Matrix',
            calendar: 'Calendar',
            completed: 'Completed'
        };

        const subtitle = this.getViewSubtitle(viewName);

        const titleEl = document.getElementById('currentViewTitle');
        const subtitleEl = document.getElementById('currentViewSubtitle');

        if (titleEl) titleEl.textContent = titles[viewName] || viewName;
        if (subtitleEl) subtitleEl.textContent = subtitle;
    }

    getViewSubtitle(viewName) {
        const today = new Date();
        const options = { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        };

        switch (viewName) {
            case 'today':
                return today.toLocaleDateString(undefined, options);
            case 'upcoming':
                return 'Next 7 days';
            case 'all':
                return `${this.tasks.filter(t => !t.completed).length} active tasks`;
            case 'matrix':
                return 'Eisenhower Decision Matrix';
            case 'calendar':
                return 'Calendar view';
            case 'completed':
                return `${this.tasks.filter(t => t.completed).length} completed tasks`;
            default:
                return '';
        }
    }

    renderCurrentView() {
        console.log('üîÑ renderCurrentView() called - current view:', this.currentView);
        
        document.querySelectorAll('.task-view').forEach(view => {
            view.classList.remove('active');
        });

        const currentViewEl = document.getElementById(`${this.currentView}View`);
        console.log('üîç Current view element found:', !!currentViewEl, `(${this.currentView}View)`);
        
        if (currentViewEl) {
            currentViewEl.classList.add('active');
        }

        console.log('üéØ Rendering view type:', this.currentView);
        
        switch (this.currentView) {
            case 'today':
                console.log('üìÖ Rendering today tasks...');
                this.renderTodayTasks();
                break;
            case 'upcoming':
                console.log('üìÜ Rendering upcoming tasks...');
                this.renderUpcomingTasks();
                break;
            case 'all':
                console.log('üìã Rendering all tasks...');
                this.renderAllTasks();
                break;
            case 'matrix':
                console.log('üî≤ Rendering priority matrix...');
                this.renderPriorityMatrix();
                break;
            case 'calendar':
                console.log('üìÖ Rendering calendar view...');
                this.renderCalendarView();
                break;
            case 'completed':
                console.log('‚úÖ Rendering completed tasks...');
                this.renderCompletedTasks();
                break;
            default:
                console.warn('‚ö†Ô∏è Unknown view type:', this.currentView);
        }
        
        console.log('‚úÖ renderCurrentView() completed');
    }

    // Filter Management Methods
    setupFilterListeners() {
        const priorityFilter = document.getElementById('priorityFilter');
        const tagFilter = document.getElementById('tagFilter');
        const projectFilter = document.getElementById('projectFilter');

        if (priorityFilter) {
            priorityFilter.addEventListener('change', (e) => {
                this.activeFilters.priority = e.target.value;
                this.applyFilters();
            });
        }

        if (tagFilter) {
            tagFilter.addEventListener('input', (e) => {
                this.activeFilters.tags = e.target.value.toLowerCase();
                this.applyFilters();
            });
        }

        if (projectFilter) {
            projectFilter.addEventListener('change', (e) => {
                this.activeFilters.project = e.target.value;
                this.applyFilters();
            });
        }
    }

    updateProjectFilterOptions() {
        const projectFilter = document.getElementById('projectFilter');
        if (!projectFilter) return;

        // Preserve current selection
        const currentSelection = projectFilter.value;
        
        // Clear and rebuild options
        projectFilter.innerHTML = '<option value="">All Projects</option>';
        
        this.projects.forEach(project => {
            const option = document.createElement('option');
            option.value = project.id;
            option.textContent = project.name;
            projectFilter.appendChild(option);
        });

        // Restore selection if it still exists
        if (currentSelection && this.projects.find(p => p.id === currentSelection)) {
            projectFilter.value = currentSelection;
        }
    }

    applyFilters() {
        console.log('üîç Applying filters:', this.activeFilters);
        this.renderCurrentView();
    }

    filterTasks(tasks) {
        if (!tasks) return [];
        
        return tasks.filter(task => {
            // Priority filter
            if (this.activeFilters.priority && task.priority !== this.activeFilters.priority) {
                return false;
            }

            // Tag filter
            if (this.activeFilters.tags) {
                const taskTags = task.tags || [];
                const tagMatch = taskTags.some(tag => 
                    tag.toLowerCase().includes(this.activeFilters.tags)
                ) || task.title.toLowerCase().includes(this.activeFilters.tags) ||
                    (task.description && task.description.toLowerCase().includes(this.activeFilters.tags));
                
                if (!tagMatch) return false;
            }

            // Project filter
            if (this.activeFilters.project && task.project !== this.activeFilters.project) {
                return false;
            }

            return true;
        });
    }

    clearFilters() {
        this.activeFilters = {
            priority: '',
            tags: '',
            project: ''
        };

        // Reset filter UI
        const priorityFilter = document.getElementById('priorityFilter');
        const tagFilter = document.getElementById('tagFilter');
        const projectFilter = document.getElementById('projectFilter');

        if (priorityFilter) priorityFilter.value = '';
        if (tagFilter) tagFilter.value = '';
        if (projectFilter) projectFilter.value = '';

        this.renderCurrentView();
    }

    renderTodayTasks() {
        const today = new Date().toISOString().split('T')[0];
        const todayTasks = this.tasks.filter(task => 
            task.dueDate === today && !task.completed
        );

        const filteredTasks = this.filterTasks(todayTasks);
        this.renderTaskList('todayTasks', filteredTasks);
    }

    renderUpcomingTasks() {
        const today = new Date();
        const nextWeek = new Date(today.getTime() + 7 * 24 * 60 * 60 * 1000);

        const upcomingTasks = this.tasks.filter(task => {
            if (!task.dueDate || task.completed) return false;
            const taskDate = new Date(task.dueDate);
            return taskDate > today && taskDate <= nextWeek;
        });

        const filteredTasks = this.filterTasks(upcomingTasks);
        this.renderTaskList('upcomingTasks', filteredTasks);
    }

    renderAllTasks() {
        const activeTasks = this.tasks.filter(task => !task.completed);
        const filteredTasks = this.filterTasks(activeTasks);
        this.renderTaskList('allTasks', filteredTasks);
    }

    renderCompletedTasks() {
        const completedTasks = this.tasks.filter(task => task.completed);
        const filteredTasks = this.filterTasks(completedTasks);
        this.renderTaskList('completedTasks', filteredTasks);
    }

    renderTaskList(containerId, tasks) {
        const container = document.getElementById(containerId);

        if (!container) return;

        if (tasks.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-tasks"></i>
                    <h3>No tasks found</h3>
                    <p>Add your first task to get started!</p>
                </div>
            `;
            return;
        }

        // Use the same working structure as matrix tasks
        container.innerHTML = tasks.map(task => {
            const priorityClass = this.getPriorityClass(task.priority);
            const priorityLabel = this.getPriorityLabel(task.priority);
            const project = this.projects.find(p => p.id === task.project);
            
            // Check if task is overdue
            const now = new Date();
            const dueDate = task.dueDate ? new Date(task.dueDate + (task.dueTime ? `T${task.dueTime}` : 'T23:59')) : null;
            const isOverdue = dueDate && dueDate < now && !task.completed;

            return `
                <div class="task-item ${task.completed ? 'completed' : ''} ${priorityClass} ${isOverdue ? 'overdue' : ''}" data-task-id="${task.id}">
                    <div class="task-header">
                        <div class="task-content">
                            <div class="task-title">${this.escapeHtml(task.title)}</div>
                            ${task.description ? `<div class="task-description">${this.escapeHtml(task.description.length > 80 ? task.description.substring(0, 80) + '...' : task.description)}</div>` : ''}
                        </div>
                        <div class="task-actions">
                            <button class="btn btn--small btn--secondary" onclick="app.toggleTask('${task.id}')" title="${task.completed ? 'Mark incomplete' : 'Mark complete'}">
                                <i class="fas fa-${task.completed ? 'undo' : 'check'}"></i>
                            </button>
                            <button class="btn btn--small btn--secondary" onclick="app.editTask('${task.id}')" title="Edit task">
                                <i class="fas fa-edit"></i>
                            </button>
                            <button class="btn btn--small btn--secondary" onclick="app.expandTask('${task.id}')" title="View full details">
                                <i class="fas fa-expand-alt"></i>
                            </button>
                            <button class="btn btn--small btn--danger" onclick="app.deleteTask('${task.id}')" title="Delete task">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>

                    <div class="task-meta">
                        <span class="task-priority ${priorityClass}">${priorityLabel}</span>

                        ${project ? `<span class="task-project" style="background: ${project.color}20; color: ${project.color}; padding: 2px 8px; border-radius: 12px; font-size: 12px;">${project.name}</span>` : ''}

                        ${task.tags && task.tags.length > 0 ? `
                            <div class="task-tags">
                                ${task.tags.map(tag => `<span class="task-tag">${this.escapeHtml(tag)}</span>`).join('')}
                            </div>
                        ` : ''}

                        ${task.dueDate ? `
                            <div class="task-date">
                                <i class="fas fa-calendar"></i>
                                ${this.formatDate(task.dueDate)}
                                ${task.dueTime ? ' ' + task.dueTime : ''}
                            </div>
                        ` : ''}

                        ${isOverdue ? '<span class="task-overdue"><i class="fas fa-exclamation-triangle"></i> Overdue</span>' : ''}
                    </div>
                </div>
            `;
        }).join('');
    }

    renderTaskItem(task) {
        const priorityClass = this.getPriorityClass(task.priority);
        const priorityLabel = this.getPriorityLabel(task.priority);
        const project = this.projects.find(p => p.id === task.project);
        
        // Check if task is overdue
        const now = new Date();
        const dueDate = task.dueDate ? new Date(task.dueDate + (task.dueTime ? `T${task.dueTime}` : 'T23:59')) : null;
        const isOverdue = dueDate && dueDate < now && !task.completed;
        
        // Get AI analysis for reminder suggestion
        const aiAnalysis = this.analyzeTaskForReminder(task);
        
        // Reminder and calendar indicators for top-right corner
        let indicators = '';
        
        // Reminder sent indicator
        if (task.reminderSent) {
            indicators += `
                <span class="task-indicator reminder-sent" 
                      title="üìß Reminder sent to ${task.reminderEmail || 'unknown'} on ${new Date(task.reminderSentAt).toLocaleDateString()}">
                    <i class="fas fa-envelope-circle-check"></i>
                </span>
            `;
        }
        
        // AI suggestion indicator
        if (!task.reminderSent && aiAnalysis.shouldSendReminder && aiAnalysis.confidence >= 70) {
            indicators += `
                <span class="task-indicator ai-suggests" 
                      title="ü§ñ AI suggests calendar reminder (${aiAnalysis.confidence}%): ${aiAnalysis.reason}">
                    <i class="fas fa-robot"></i>
                </span>
            `;
        }
        
        // Calendar event indicator
        if (task.calendarEventId) {
            indicators += `
                <span class="task-indicator calendar-created" 
                      title="üìÖ Calendar event created${task.aiReminderSuggested ? ' by AI' : ''}">
                    <i class="fas fa-calendar-check"></i>
                </span>
            `;
        }

        return `
            <div class="task-item ${task.completed ? 'completed' : ''} ${priorityClass} ${isOverdue ? 'overdue' : ''}" data-task-id="${task.id}">
                ${indicators ? `<div class="task-indicators">${indicators}</div>` : ''}
                
                <div class="task-header">
                    <div class="task-content">
                        <div class="task-title">${this.escapeHtml(task.title)}</div>
                        ${task.description ? `<div class="task-description">${this.escapeHtml(task.description.length > 80 ? task.description.substring(0, 80) + '...' : task.description)}</div>` : ''}
                    </div>
                    <div class="task-actions">
                        <button class="btn btn--small btn--secondary" onclick="app.toggleTask('${task.id}')" title="${task.completed ? 'Mark incomplete' : 'Mark complete'}">
                            <i class="fas fa-${task.completed ? 'undo' : 'check'}"></i>
                        </button>
                        <button class="btn btn--small btn--secondary" onclick="app.editTask('${task.id}')" title="Edit task">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn--small btn--secondary" onclick="app.expandTask('${task.id}')" title="View full details">
                            <i class="fas fa-expand-alt"></i>
                        </button>
                        <button class="btn btn--small btn--danger" onclick="app.deleteTask('${task.id}')" title="Delete task">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>

                <div class="task-meta">
                    <span class="task-priority ${priorityClass}">${priorityLabel}</span>

                    ${project ? `<span class="task-project" style="background: ${project.color}20; color: ${project.color}; padding: 2px 8px; border-radius: 12px; font-size: 12px;">${project.name}</span>` : ''}

                    ${task.tags && task.tags.length > 0 ? `
                        <div class="task-tags">
                            ${task.tags.map(tag => `<span class="task-tag">${this.escapeHtml(tag)}</span>`).join('')}
                        </div>
                    ` : ''}

                    ${task.dueDate ? `
                        <div class="task-date">
                            <i class="fas fa-calendar"></i>
                            ${this.formatDate(task.dueDate)}
                            ${task.dueTime ? ' ' + task.dueTime : ''}
                        </div>
                    ` : ''}

                    ${task.isRecurring ? '<span class="recurring-badge"><i class="fas fa-redo"></i> Recurring</span>' : ''}
                    ${task.calendarEvent ? '<span class="calendar-badge"><i class="fas fa-calendar-check"></i> Calendar Event</span>' : ''}
                </div>
            </div>
        `;
    }

    renderPriorityMatrix() {
        console.log('üéØ Rendering Priority Matrix with', this.tasks.filter(task => !task.completed).length, 'active tasks');
        
        const quadrants = {
            'important-immediate': [],
            'immediate-not-important-urgent': [],
            'important-not-immediate': [],
            'immediate-not-important': [],
            'not-important-not-immediate': []
        };

        // Apply filters to active tasks before categorizing
        const activeTasks = this.tasks.filter(task => !task.completed);
        const filteredTasks = this.filterTasks(activeTasks);
        
        filteredTasks.forEach(task => {
            // Smart delegate detection for grocery/shopping tasks
            if (this.isDelegateTask(task)) {
                quadrants['immediate-not-important'].push(task);
                return;
            }
            
            // Use the EXACT working logic from v2.13
            const key = this.getPriorityKey(task.priority);
            console.log('Task:', task.title, 'Priority key:', key);
            if (quadrants[key]) {
                quadrants[key].push(task);
            }
        });

        Object.keys(quadrants).forEach(quadrant => {
            const container = document.getElementById(`matrix-${quadrant}`);
            if (!container) {
                console.log('‚ùå Container not found:', `matrix-${quadrant}`);
                return;
            }

            const tasks = quadrants[quadrant];
            console.log(`üìã Quadrant ${quadrant}:`, tasks.length, 'tasks');

            if (tasks.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>No tasks in this quadrant</p></div>';
            } else {
                // Use matrix-specific rendering with action buttons
                container.innerHTML = tasks.map(task => {
                    const priorityClass = this.getPriorityClass(task.priority);
                    const priorityLabel = this.getPriorityLabel(task.priority);
                    const project = this.projects.find(p => p.id === task.project);
                    
                    // Check if task is overdue
                    const now = new Date();
                    const dueDate = task.dueDate ? new Date(task.dueDate + (task.dueTime ? `T${task.dueTime}` : 'T23:59')) : null;
                    const isOverdue = dueDate && dueDate < now && !task.completed;
                    
                    return `
                    <div class="matrix-task" data-task-id="${task.id}">
                        <div class="matrix-task-header">
                            <div class="matrix-task-content">
                                <strong>${this.escapeHtml(task.title)}</strong>
                                ${task.description ? `<div style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">${this.escapeHtml(task.description)}</div>` : ''}
                                
                                <!-- Task Meta Information -->
                                <div class="matrix-task-meta" style="margin-top: 8px; display: flex; flex-wrap: wrap; gap: 6px; align-items: center;">
                                    ${project ? `<span class="task-project" style="background: ${project.color}20; color: ${project.color}; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 500;">${project.name}</span>` : ''}
                                    
                                    ${task.tags && task.tags.length > 0 ? task.tags.map(tag => `<span class="task-tag" style="background: var(--bg-tertiary); color: var(--text-secondary); padding: 2px 6px; border-radius: 8px; font-size: 10px;">${this.escapeHtml(tag)}</span>`).join('') : ''}
                                    
                                    ${task.dueDate ? `<span class="task-date" style="font-size: 11px; color: var(--text-tertiary); display: flex; align-items: center; gap: 4px;">
                                        <i class="fas fa-calendar" style="font-size: 9px;"></i>
                                        ${this.formatDate(task.dueDate)}
                                        ${task.dueTime ? ' ' + task.dueTime : ''}
                                    </span>` : ''}
                                    
                                    ${isOverdue ? '<span class="task-overdue" style="background: #ef444420; color: #ef4444; padding: 2px 6px; border-radius: 8px; font-size: 10px; font-weight: 500; display: flex; align-items: center; gap: 2px;"><i class="fas fa-exclamation-triangle" style="font-size: 8px;"></i> Overdue</span>' : ''}
                                    
                                    ${task.isRecurring ? '<span style="background: var(--primary-color)20; color: var(--primary-color); padding: 2px 6px; border-radius: 8px; font-size: 10px; display: flex; align-items: center; gap: 2px;"><i class="fas fa-redo" style="font-size: 8px;"></i> Recurring</span>' : ''}
                                    
                                    ${task.calendarEvent ? '<span style="background: var(--primary-color)20; color: var(--primary-color); padding: 2px 6px; border-radius: 8px; font-size: 10px; display: flex; align-items: center; gap: 2px;"><i class="fas fa-calendar-check" style="font-size: 8px;"></i> Synced</span>' : ''}
                                </div>
                            </div>
                            <div class="matrix-task-actions">
                                <button class="btn btn--small btn--secondary" onclick="app.toggleTask('${task.id}')" title="${task.completed ? 'Mark incomplete' : 'Mark complete'}">
                                    <i class="fas fa-${task.completed ? 'undo' : 'check'}"></i>
                                </button>
                                <button class="btn btn--small btn--secondary" onclick="app.editTask('${task.id}')" title="Edit task">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn btn--small btn--secondary" onclick="app.expandTask('${task.id}')" title="View full details">
                                    <i class="fas fa-expand-alt"></i>
                                </button>
                                <button class="btn btn--small btn--danger" onclick="app.deleteTask('${task.id}')" title="Delete task">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;}).join('');
                console.log(`‚úÖ Rendered ${tasks.length} tasks in ${quadrant}`);
            }
        });
    }

    // Smart delegate task detection
    isDelegateTask(task) {
        const delegateKeywords = [
            'grocery', 'groceries', 'shopping', 'shop', 'buy', 'purchase',
            'pick up', 'pickup', 'get from store', 'store', 'market',
            'milk', 'bread', 'eggs', 'food', 'dinner', 'lunch',
            'delegate', 'assign', 'share', 'send to', 'ask someone'
        ];
        
        const taskText = (task.title + ' ' + (task.description || '')).toLowerCase();
        return delegateKeywords.some(keyword => taskText.includes(keyword));
    }

    // Email delegate tasks functionality
    emailDelegateTasks() {
        const delegateTasks = this.tasks.filter(task => {
            if (task.completed) return false;
            
            // Check if priority is "immediate-not-important" (delegate quadrant)
            const priorityString = this.convertPriorityToString(task.priority);
            return priorityString === 'immediate-not-important' || this.isDelegateTask(task);
        });
        
        if (delegateTasks.length === 0) {
            alert('No delegate tasks to share!');
            return;
        }
        
        const emailSubject = `Delegate Tasks from TaskFlow - ${new Date().toLocaleDateString()}`;
        const emailBody = `Hi there!

Here are the delegate tasks from TaskFlow:

${delegateTasks.map((task, index) => `${index + 1}. ${task.title}${task.description ? '\n   ' + task.description : ''}${task.dueDate ? '\n   Due: ' + task.dueDate : ''}`).join('\n\n')}

Best regards,
TaskFlow`;
        
        // Use simple mailto (this works reliably without breaking authentication)
        const emailInput = prompt('Enter email address to share with:', '');
        if (emailInput && emailInput.trim()) {
            const mailtoLink = `mailto:${emailInput.trim()}?subject=${encodeURIComponent(emailSubject)}&body=${encodeURIComponent(emailBody)}`;
            
            // Open mailto link
            window.open(mailtoLink);
            
            this.showNotification(`Shared ${delegateTasks.length} delegate tasks via email!`, 'success');
        }
    }

    renderCalendarView() {
        const container = document.getElementById('calendarMain');
        if (container) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-calendar-alt"></i>
                    <h3>Calendar Integration</h3>
                    <p>Connect your calendar in Settings to view events here!</p>
                    <button class="btn btn--primary" onclick="app.showSettingsModal(); app.switchSettingsTab('calendar');">
                        <i class="fas fa-cog"></i> Setup Calendar
                    </button>
                </div>
            `;
        }
    }

    // Keep all other existing methods (updateProjectsList, showAddTaskModal, etc.)
    updateProjectsList() {
        const container = document.getElementById('projectsList');
        if (!container) return;

        container.innerHTML = this.projects.map(project => {
            const taskCount = this.tasks.filter(t => t.project === project.id && !t.completed).length;
            return `
                <li class="menu-item project-item" data-project="${project.id}" onclick="app.filterByProject('${project.id}')">
                    <div class="project-color" style="background: ${project.color};"></div>
                    <span>${this.escapeHtml(project.name)}</span>
                    <span class="count">${taskCount}</span>
                </li>
            `;
        }).join('');
    }

    showAddProjectModal() {
        const projectName = prompt('Enter project name:', '');
        if (!projectName || !projectName.trim()) return;

        const projectColors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#84cc16', '#f97316'];
        const usedColors = this.projects.map(p => p.color);
        const availableColors = projectColors.filter(c => !usedColors.includes(c));
        const projectColor = availableColors.length > 0 ? availableColors[0] : projectColors[Math.floor(Math.random() * projectColors.length)];

        const project = {
            id: 'project_' + Date.now(),
            name: projectName.trim(),
            color: projectColor
        };

        this.projects.push(project);
        this.saveProjects();
        this.updateProjectsList();
        this.updateProjectSelectors();
        this.updateProjectChips(); // Update chips too
        this.showNotification(`Project "${project.name}" created!`, 'success');
    }

    // Update tags list in sidebar
    updateTagsList() {
        const container = document.getElementById('tagsList');
        if (!container) return;

        container.innerHTML = this.tags.map(tag => {
            const taskCount = this.tasks.filter(t => t.tags && t.tags.includes(tag.name) && !t.completed).length;
            return `
                <li class="menu-item tag-item" data-tag="${tag.id}" onclick="app.filterByTag('${tag.name}')">
                    <div class="project-color" style="background: ${tag.color};"></div>
                    <span>${this.escapeHtml(tag.name)}</span>
                    <span class="count">${taskCount}</span>
                </li>
            `;
        }).join('');
    }

    // Show add tag modal
    showAddTagModal() {
        const tagName = prompt('Enter tag name:', '');
        if (!tagName || !tagName.trim()) return;

        const tagColors = ['#f59e0b', '#ef4444', '#dc2626', '#f97316', '#0891b2', '#059669', '#8b5cf6', '#06b6d4'];
        const usedColors = this.tags.map(t => t.color);
        const availableColors = tagColors.filter(c => !usedColors.includes(c));
        const tagColor = availableColors.length > 0 ? availableColors[0] : tagColors[Math.floor(Math.random() * tagColors.length)];

        const tag = {
            id: 'tag_' + Date.now(),
            name: tagName.trim(),
            color: tagColor
        };

        this.tags.push(tag);
        this.saveTags();
        this.updateTagsList();
        this.generateAISuggestedTags(); // Update suggested tags in add task modal
        this.showNotification(`Tag "${tag.name}" created!`, 'success');
    }

    // Filter by tag
    filterByTag(tagName) {
        console.log('Filtering by tag:', tagName);
        // TODO: Implement tag filtering
        this.showNotification(`Filtering by tag: ${tagName}`, 'info');
    }

    // Save tags to localStorage
    saveTags() {
        localStorage.setItem('taskflow_tags', JSON.stringify(this.tags));
    }

    updateProjectSelectors() {
        const taskProjectSelect = document.getElementById('taskProject');
        const filterProjectSelect = document.getElementById('projectFilter');

        const optionsHtml = '<option value="">No Project</option>' + 
            this.projects.map(project => 
                `<option value="${project.id}">${this.escapeHtml(project.name)}</option>`
            ).join('');

        if (taskProjectSelect) taskProjectSelect.innerHTML = optionsHtml;
        if (filterProjectSelect) {
            filterProjectSelect.innerHTML = '<option value="">All Projects</option>' + 
                this.projects.map(project => 
                    `<option value="${project.id}">${this.escapeHtml(project.name)}</option>`
                ).join('');
        }
    }

    getSelectedPriority() {
        const selected = document.querySelector('.priority-option-fixed.selected');
        if (selected) {
            const priority = selected.getAttribute('data-priority');
            console.log('üéØ Selected priority:', priority);
            return priority;
        }
        console.log('‚ö†Ô∏è No priority selected, defaulting to not-important-not-immediate');
        return 'not-important-not-immediate';
    }

    // Convert string priority to object for matrix sorting
    convertPriorityToObject(priorityString) {
        console.log('üîÑ Converting priority string to object:', priorityString);
        switch (priorityString) {
            case 'important-immediate':
                return { important: true, immediate: true };
            case 'important-not-immediate':
                return { important: true, immediate: false };
            case 'immediate-not-important':
                return { important: false, immediate: true };
            case 'not-important-not-immediate':
            default:
                return { important: false, immediate: false };
        }
    }

    // Convert priority object back to string for display/editing
    convertPriorityToString(priorityObj) {
        // Handle legacy string priorities
        if (typeof priorityObj === 'string') {
            return priorityObj;
        }
        
        // Convert object to string
        if (priorityObj && typeof priorityObj === 'object') {
            if (priorityObj.important && priorityObj.immediate) {
                return 'important-immediate';
            } else if (priorityObj.important && !priorityObj.immediate) {
                return 'important-not-immediate';
            } else if (!priorityObj.important && priorityObj.immediate) {
                return 'immediate-not-important';
            } else {
                return 'not-important-not-immediate';
            }
        }
        
        return 'not-important-not-immediate'; // default
    }

    toggleTask(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (task) {
            task.completed = !task.completed;
            task.completedAt = task.completed ? new Date().toISOString() : null;

            this.saveTasks();
            this.updateTaskCounts();
            this.renderCurrentView();
            this.updateStats();
            this.updateProjectsList();

            this.showNotification(
                task.completed ? 'Task completed!' : 'Task marked as pending',
                'success'
            );
        }
    }

    async deleteTask(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) {
            console.error('Task not found:', taskId);
            return;
        }

        if (confirm('Are you sure you want to delete this task?')) {
            console.log('üîç Task details:', {
                id: task.id,
                title: task.title,
                dueDate: task.dueDate,
                dueTime: task.dueTime
            });
            
            // Delete calendar event if auto-delete is enabled
            const autoDeleteEvents = document.getElementById('autoDeleteEvents')?.checked ?? true;
            console.log('‚öôÔ∏è Auto-delete events setting:', autoDeleteEvents);
            
            if (autoDeleteEvents) {
                console.log('üóëÔ∏è Searching for calendar events to delete for task:', task.title);
                try {
                    const deleted = await deleteGoogleCalendarEventByTask(task);
                    if (deleted) {
                        console.log('‚úÖ Calendar event(s) deleted successfully');
                    } else {
                        console.log('‚ÑπÔ∏è No matching calendar events found to delete');
                    }
                } catch (err) {
                    console.error('‚ùå Error deleting calendar event:', err);
                    // Continue with task deletion even if calendar deletion fails
                }
            } else {
                console.log('‚ÑπÔ∏è Calendar event deletion disabled in settings');
            }

            // Remove from tasks array
            this.tasks = this.tasks.filter(t => t.id !== taskId);
            
            // Delete from Firestore if authenticated
            if (this.useFirestore && this.firebaseUserId) {
                try {
                    await window.FirebaseManager.deleteTask(this.firebaseUserId, taskId);
                } catch (error) {
                    console.error('‚ùå Error deleting from Firestore:', error);
                }
            }
            
            this.saveTasks();
            this.updateTaskCounts();
            this.renderCurrentView();
            this.updateStats();
            this.updateProjectsList();
            this.showNotification('Task deleted successfully!', 'success');
            
            // Show additional notification if calendar events were also deleted
            if (autoDeleteEvents) {
                setTimeout(() => {
                    this.showNotification('Calendar reminders also removed', 'info');
                }, 1000);
            }
        }
    }

    showTaskDetails(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (task) {
            const details = `Task: ${task.title}

Description: ${task.description || 'No description'}

Due: ${task.dueDate ? this.formatDate(task.dueDate) : 'No due date'}${task.dueTime ? ' at ' + task.dueTime : ''}

Priority: ${this.getPriorityLabel(task.priority)}

Project: ${this.projects.find(p => p.id === task.project)?.name || 'None'}

Tags: ${task.tags.length > 0 ? task.tags.join(', ') : 'None'}

Recurring: ${task.isRecurring ? 'Yes' : 'No'}

Calendar Event: ${task.calendarEvent ? 'Yes' : 'No'}`;

            alert(details);
        }
    }

    sendEmailReminder(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) return;

        if (this.userEmails.length === 0) {
            this.showNotification('Please add email addresses in Settings first', 'error');
            return;
        }

        const defaultEmail = this.userEmails.find(e => e.isDefault) || this.userEmails[0];

        const subject = `TaskFlow Reminder: ${task.title}`;
        const body = `Task: ${task.title}

Description: ${task.description || 'No description'}

Due: ${task.dueDate ? this.formatDate(task.dueDate) : 'No due date'}${task.dueTime ? ' at ' + task.dueTime : ''}

Priority: ${this.getPriorityLabel(task.priority)}

${task.calendarEvent ? `Calendar Event: ${task.calendarEvent.url}` : ''}

${task.isRecurring ? 'This is a recurring task.' : ''}

---
This reminder was created by TaskFlow v2.3.
Complete this task and stay productive!`;

        const mailtoLink = `mailto:${defaultEmail.email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

        try {
            window.open(mailtoLink, '_blank');
            this.showNotification(`Email reminder opened for ${defaultEmail.email}`, 'success');
        } catch (error) {
            this.showNotification('Could not open email client', 'error');
        }
    }

    openCalendarEvent(taskId) {
        const task = this.tasks.find(t => t.id === taskId);
        if (task && task.calendarEvent && task.calendarEvent.url) {
            window.open(task.calendarEvent.url, '_blank');
        } else {
            this.showNotification('Calendar event not found', 'error');
        }
    }

    showAddTaskModal() {
        console.log('üéØ Opening Add Task modal...');
        const modal = document.getElementById('addTaskModal');
        if (modal) {
            console.log('‚úÖ Modal found, adding show class');
            modal.classList.add('show');
            this.updateProjectSelectors();
            this.updateProjectChips(); // NEW: Update project chips
            this.updateCalendarSelectors();
            this.generateAISuggestedTags(); // NEW: Generate AI tag suggestions

            const titleInput = document.getElementById('taskTitle');
            if (titleInput) {
                setTimeout(() => {
                    titleInput.focus();
                    // Initialize AI preview
                    console.log('ü§ñ Initializing AI preview...');
                    this.updateAIReminderPreview();
                }, 100);
            }
            
            // Ensure AI preview event listeners are set up
            this.setupAIPreviewListeners();
        } else {
            console.error('‚ùå Add Task modal not found!');
        }
    }
    
    // Update project chips
    updateProjectChips() {
        const projectChips = document.getElementById('projectChips');
        const taskProjectInput = document.getElementById('taskProject');
        if (!projectChips) {
            console.error('‚ùå Project chips container not found');
            return;
        }

        // Get ALL defined projects (not just ones with tasks)
        const projects = this.projects || [];
        
        console.log('üìÅ All defined projects:', projects);
        console.log('üìÅ Projects count:', projects.length);
        
        // Clear chips
        projectChips.innerHTML = '';
        
        if (projects.length === 0) {
            projectChips.innerHTML = '<small style="color: var(--text-secondary); padding: 8px;">No projects yet. Create projects from the sidebar.</small>';
            return;
        }
        
        // Add project chips for ALL defined projects
        projects.forEach(project => {
            console.log('‚úÖ Adding project chip:', project.name);
            const chip = document.createElement('div');
            chip.className = 'chip';
            chip.dataset.project = project.id; // Use project ID
            chip.innerHTML = `
                <i class="fas fa-folder" style="color: ${project.color}"></i>
                <span>${project.name}</span>
            `;
            chip.addEventListener('click', () => {
                // Deselect all chips
                projectChips.querySelectorAll('.chip').forEach(c => c.classList.remove('selected'));
                // Select this chip
                chip.classList.add('selected');
                // Update hidden input with project ID
                taskProjectInput.value = project.id;
                console.log('üìÅ Project selected:', project.name, 'ID:', project.id);
            });
            projectChips.appendChild(chip);
        });
        
        // Default: no project selected (empty value)
        taskProjectInput.value = '';
        console.log('‚úÖ Project chips updated successfully');
    }
    
    // Generate AI-suggested tags
    generateAISuggestedTags() {
        const suggestedTagsContainer = document.getElementById('suggestedTags');
        const taskTagsInput = document.getElementById('taskTags');
        if (!suggestedTagsContainer) return;

        // Start with defined tags from sidebar
        const definedTags = this.tags.map(t => t.name);
        
        // Get common tags from existing tasks
        const allTags = this.tasks.flatMap(t => t.tags);
        const tagCounts = {};
        allTags.forEach(tag => {
            tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
        
        // Sort by frequency
        const popularTags = Object.entries(tagCounts)
            .sort((a, b) => b[1] - a[1])
            .map(([tag]) => tag);
        
        // Combine: defined tags first, then popular tags
        const allSuggestions = [...new Set([...definedTags, ...popularTags])];
        const suggestedTags = allSuggestions.slice(0, 10); // Show top 10
        
        console.log('üè∑Ô∏è Suggested tags:', suggestedTags);
        
        // Clear and rebuild suggested tags
        suggestedTagsContainer.innerHTML = '';
        
        suggestedTags.forEach(tag => {
            // Find if this is a defined tag to get its color
            const definedTag = this.tags.find(t => t.name === tag);
            const tagColor = definedTag ? definedTag.color : '#6b7280';
            
            const tagChip = document.createElement('div');
            tagChip.className = 'tag-chip';
            tagChip.style.borderColor = tagColor;
            tagChip.innerHTML = `
                <i class="fas fa-plus-circle" style="color: ${tagColor}"></i>
                <span>${tag}</span>
            `;
            tagChip.addEventListener('click', () => {
                // Add tag to input
                const currentTags = taskTagsInput.value.trim();
                const tagsArray = currentTags ? currentTags.split(',').map(t => t.trim()) : [];
                
                if (!tagsArray.includes(tag)) {
                    tagsArray.push(tag);
                    taskTagsInput.value = tagsArray.join(', ');
                }
                
                // Remove this tag chip (with fade animation)
                tagChip.style.opacity = '0';
                tagChip.style.transform = 'scale(0.8)';
                setTimeout(() => tagChip.remove(), 200);
            });
            suggestedTagsContainer.appendChild(tagChip);
        });
    }
    
    // AI Tag Detection - Auto-add/remove tags based on title/description
    detectAndAutoAddTags() {
        const titleInput = document.getElementById('taskTitle');
        const descInput = document.getElementById('taskDescription');
        const tagsInput = document.getElementById('taskTags');
        
        if (!titleInput || !descInput || !tagsInput) return;
        
        const title = titleInput.value.toLowerCase();
        const description = descInput.value.toLowerCase();
        const combinedText = `${title} ${description}`;
        
        // Get current tags in the input
        const currentTags = tagsInput.value.trim();
        const currentTagsArray = currentTags ? currentTags.split(',').map(t => t.trim()) : [];
        
        // Detect which defined tags should be auto-added
        const detectedTags = [];
        this.tags.forEach(tag => {
            const tagName = tag.name.toLowerCase();
            if (combinedText.includes(tagName)) {
                detectedTags.push(tag.name);
            }
        });
        
        console.log('üè∑Ô∏è AI Tag Detection:', {
            combinedText,
            detectedTags,
            currentTags: currentTagsArray
        });
        
        // Build new tags array
        // Keep manually added tags that aren't detected tags
        const manualTags = currentTagsArray.filter(tag => {
            const tagLower = tag.toLowerCase();
            // Keep if it's NOT a defined tag name, OR if it's detected
            const isDefinedTag = this.tags.some(t => t.name.toLowerCase() === tagLower);
            if (!isDefinedTag) return true; // Keep manual tags
            return detectedTags.some(dt => dt.toLowerCase() === tagLower); // Keep if detected
        });
        
        // Combine manual tags with detected tags (no duplicates)
        const newTagsArray = [...new Set([...manualTags, ...detectedTags])];
        
        // Update input only if changed
        const newTagsString = newTagsArray.join(', ');
        if (newTagsString !== currentTags) {
            tagsInput.value = newTagsString;
            console.log('‚úÖ Tags auto-updated:', newTagsString);
            
            // Regenerate suggestions (remove detected tags from suggestions)
            this.generateAISuggestedTags();
        }
    }
    
    // Setup AI preview listeners (called when modal opens)
    setupAIPreviewListeners() {
        console.log('üéØ Setting up AI preview listeners...');
        
        // Remove existing listeners to prevent duplicates
        const taskFormElements = ['taskTitle', 'taskDescription', 'taskDate', 'taskTime', 'taskTags'];
        taskFormElements.forEach(elementId => {
            const element = document.getElementById(elementId);
            if (element) {
                console.log(`‚úÖ Found element: ${elementId}`);
                // Remove existing listeners
                element.removeEventListener('input', this.updateAIReminderPreview);
                element.removeEventListener('change', this.updateAIReminderPreview);
                
                // Add new listeners with proper binding
                element.addEventListener('input', () => {
                    console.log(`üìù Input event on ${elementId}: ${element.value}`);
                    this.updateAIReminderPreview();
                });
                element.addEventListener('change', () => {
                    console.log(`üîÑ Change event on ${elementId}: ${element.value}`);
                    this.updateAIReminderPreview();
                });
            } else {
                console.log(`‚ùå Element not found: ${elementId}`);
            }
        });
        
        // AI Tag Detection - Listen to title and description
        const titleInput = document.getElementById('taskTitle');
        const descInput = document.getElementById('taskDescription');
        
        if (titleInput) {
            titleInput.addEventListener('input', () => this.detectAndAutoAddTags());
        }
        if (descInput) {
            descInput.addEventListener('input', () => this.detectAndAutoAddTags());
        }
        
        // Priority buttons - click to select
        document.querySelectorAll('.priority-option-fixed').forEach(button => {
            button.removeEventListener('click', this.handlePriorityClick);
            button.addEventListener('click', (e) => {
                console.log('üéØ Priority button clicked:', button.dataset.priority);
                
                // Deselect all priority buttons
                document.querySelectorAll('.priority-option-fixed').forEach(btn => {
                    btn.classList.remove('selected');
                });
                
                // Select this button
                button.classList.add('selected');
                
                // Update AI preview
                this.updateAIReminderPreview();
            });
        });
        
        console.log('üéØ AI preview listeners set up successfully');
        
        // Force an initial update
        setTimeout(() => {
            console.log('üîÑ Forcing initial AI preview update...');
            this.updateAIReminderPreview();
        }, 100);
    }

    hideAddTaskModal() {
        console.log('üîí hideAddTaskModal() called - attempting to close modal');
        
        const modal = document.getElementById('addTaskModal');
        console.log('üîç Modal found:', !!modal);
        
        if (modal) {
            console.log('‚úÖ Removing "show" class from modal');
            modal.classList.remove('show');
            
            // FORCE HIDE: Set display none as backup
            modal.style.display = 'none';
            
            // Add back the display style after a brief moment to let CSS transitions work
            setTimeout(() => {
                modal.style.display = '';
            }, 100);

            const form = document.getElementById('taskForm');
            if (form) {
                console.log('‚úÖ Resetting form');
                form.reset();
            }
            
            console.log('üéØ Modal should now be hidden');
        } else {
            console.error('‚ùå Modal not found!');
        }
    }

    showSettingsModal() {
        console.log('‚öôÔ∏è Opening settings modal');
        const modal = document.getElementById('settingsModal');
        if (modal) {
            modal.classList.add('show');
            this.updateStorageInfo();
            
            // IMMEDIATE: Force update accounts table when settings open
            console.log('üîÑ IMMEDIATE refresh of connected accounts on settings open...');
            this.forceUpdateConnectedAccountsTable();
            
            // Refresh calendar selectors when settings open
            console.log('üîÑ Refreshing calendar selectors on settings open...');
            this.updateCalendarSelectors();
            
            // ALSO populate the dropdown with calendars
            console.log('üîÑ Force populating calendar dropdown...');
            this.forcePopulateCalendarDropdown();
        }
    }

    hideSettingsModal() {
        const modal = document.getElementById('settingsModal');
        if (modal) {
            modal.classList.remove('show');
        }
    }

    handleToolAction(action) {
        switch (action) {
            case 'settings':
                this.showSettingsModal();
                break;
            case 'meetings':
                this.showNotification('Meetings feature coming soon!', 'info');
                break;
            case 'analytics':
                this.showNotification('Analytics feature coming soon!', 'info');
                break;
        }
    }

    switchSettingsTab(tabName) {
        if (!tabName) return;

        document.querySelectorAll('.settings-tab').forEach(tab => {
            tab.classList.remove('active');
        });

        const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
        if (activeTab) {
            activeTab.classList.add('active');
        }

        document.querySelectorAll('.settings-content').forEach(content => {
            content.classList.remove('active');
        });

        const activeContent = document.getElementById(`${tabName}Tab`);
        if (activeContent) {
            activeContent.classList.add('active');
        }
    }

    toggleFilterPanel() {
        const panel = document.getElementById('filterPanel');
        if (panel) {
            const isVisible = panel.style.display === 'block';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                // Update project filter options when panel is opened
                this.updateProjectFilterOptions();
            }
        }
    }

    // Filter Management Methods
    setupFilterListeners() {
        const priorityFilter = document.getElementById('priorityFilter');
        const tagFilter = document.getElementById('tagFilter');
        const projectFilter = document.getElementById('projectFilter');

        if (priorityFilter) {
            priorityFilter.addEventListener('change', (e) => {
                this.activeFilters.priority = e.target.value;
                this.applyFilters();
            });
        }

        if (tagFilter) {
            tagFilter.addEventListener('input', (e) => {
                this.activeFilters.tags = e.target.value.toLowerCase();
                this.applyFilters();
            });
        }

        if (projectFilter) {
            projectFilter.addEventListener('change', (e) => {
                this.activeFilters.project = e.target.value;
                this.applyFilters();
            });
        }
    }

    updateProjectFilterOptions() {
        const projectFilter = document.getElementById('projectFilter');
        if (!projectFilter) return;

        // Preserve current selection
        const currentSelection = projectFilter.value;
        
        // Clear and rebuild options
        projectFilter.innerHTML = '<option value="">All Projects</option>';
        
        this.projects.forEach(project => {
            const option = document.createElement('option');
            option.value = project.id;
            option.textContent = project.name;
            projectFilter.appendChild(option);
        });

        // Restore selection if it still exists
        if (currentSelection && this.projects.find(p => p.id === currentSelection)) {
            projectFilter.value = currentSelection;
        }
    }

    applyFilters() {
        console.log('üîç Applying filters:', this.activeFilters);
        this.renderCurrentView();
    }

    filterTasks(tasks) {
        if (!tasks) return [];
        
        return tasks.filter(task => {
            // Priority filter
            if (this.activeFilters.priority && task.priority !== this.activeFilters.priority) {
                return false;
            }

            // Tag filter
            if (this.activeFilters.tags) {
                const taskTags = task.tags || [];
                const tagMatch = taskTags.some(tag => 
                    tag.toLowerCase().includes(this.activeFilters.tags)
                ) || task.title.toLowerCase().includes(this.activeFilters.tags) ||
                    (task.description && task.description.toLowerCase().includes(this.activeFilters.tags));
                
                if (!tagMatch) return false;
            }

            // Project filter
            if (this.activeFilters.project && task.project !== this.activeFilters.project) {
                return false;
            }

            return true;
        });
    }

    clearFilters() {
        this.activeFilters = {
            priority: '',
            tags: '',
            project: ''
        };

        // Reset filter UI
        const priorityFilter = document.getElementById('priorityFilter');
        const tagFilter = document.getElementById('tagFilter');
        const projectFilter = document.getElementById('projectFilter');

        if (priorityFilter) priorityFilter.value = '';
        if (tagFilter) tagFilter.value = '';
        if (projectFilter) projectFilter.value = '';

        this.renderCurrentView();
    }

    generateMiniCalendar() {
        const grid = document.getElementById('calendarGrid');
        const title = document.getElementById('calendarTitle');

        if (!grid || !title) return;

        const date = new Date(this.currentYear, this.currentMonth, 1);
        const today = new Date();

        title.textContent = date.toLocaleDateString(undefined, { month: 'short', year: 'numeric' });

        grid.innerHTML = '';

        const firstDay = date.getDay();
        const daysInMonth = new Date(this.currentYear, this.currentMonth + 1, 0).getDate();

        for (let i = 0; i < firstDay; i++) {
            const day = document.createElement('div');
            day.className = 'calendar-day';
            grid.appendChild(day);
        }

        for (let day = 1; day <= daysInMonth; day++) {
            const dayElement = document.createElement('div');
            dayElement.className = 'calendar-day';
            dayElement.textContent = day;

            const dayDate = new Date(this.currentYear, this.currentMonth, day);

            if (dayDate.toDateString() === today.toDateString()) {
                dayElement.classList.add('today');
            }

            const dayDateString = dayDate.toISOString().split('T')[0];
            const hasTasks = this.tasks.some(task => task.dueDate === dayDateString);
            if (hasTasks) {
                dayElement.classList.add('has-tasks');
            }

            grid.appendChild(dayElement);
        }
    }

    navigateCalendar(direction) {
        this.currentMonth += direction;
        if (this.currentMonth > 11) {
            this.currentMonth = 0;
            this.currentYear++;
        } else if (this.currentMonth < 0) {
            this.currentMonth = 11;
            this.currentYear--;
        }
        this.generateMiniCalendar();
    }

    updateTaskCounts() {
        const today = new Date().toISOString().split('T')[0];
        const nextWeek = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

        const todayCount = this.tasks.filter(t => t.dueDate === today && !t.completed).length;
        const upcomingCount = this.tasks.filter(t => t.dueDate && t.dueDate <= nextWeek && t.dueDate > today && !t.completed).length;
        const allCount = this.tasks.filter(t => !t.completed).length;
        const completedCount = this.tasks.filter(t => t.completed).length;

        const todayCountEl = document.getElementById('todayCount');
        const upcomingCountEl = document.getElementById('upcomingCount');
        const allCountEl = document.getElementById('allCount');
        const completedCountEl = document.getElementById('completedCount');

        if (todayCountEl) todayCountEl.textContent = todayCount;
        if (upcomingCountEl) upcomingCountEl.textContent = upcomingCount;
        if (allCountEl) allCountEl.textContent = allCount;
        if (completedCountEl) completedCountEl.textContent = completedCount;
    }

    updateStats() {
        const today = new Date().toISOString().split('T')[0];

        const totalTasks = this.tasks.length;
        const completedToday = this.tasks.filter(t => 
            t.completed && t.completedAt && t.completedAt.startsWith(today)
        ).length;
        const overdue = this.tasks.filter(t => 
            t.dueDate && t.dueDate < today && !t.completed
        ).length;

        const totalEl = document.getElementById('totalTasksStat');
        const completedEl = document.getElementById('completedTodayStat');
        const overdueEl = document.getElementById('overdueStat');

        if (totalEl) totalEl.textContent = totalTasks;
        if (completedEl) completedEl.textContent = completedToday;
        if (overdueEl) overdueEl.textContent = overdue;
    }

    updateStorageInfo() {
        const totalTasks = this.tasks.length;
        const activeTasks = this.tasks.filter(t => !t.completed).length;
        const completedTasks = this.tasks.filter(t => t.completed).length;
        const totalProjects = this.projects.length;

        const dataSize = JSON.stringify({
            tasks: this.tasks,
            projects: this.projects,
            settings: this.settings
        }).length;
        const storageKB = Math.round(dataSize / 1024 * 100) / 100;

        const updateElement = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
        };

        updateElement('totalTasksCount', totalTasks);
        updateElement('activeTasksCount', activeTasks);
        updateElement('completedTasksCount', completedTasks);
        updateElement('totalProjectsCount', totalProjects);
        updateElement('storageUsed', `${storageKB} KB`);
    }

    exportData(format) {
        console.log(`üì§ Exporting data as ${format.toUpperCase()}`);

        const data = {
            tasks: this.tasks,
            projects: this.projects,
            settings: this.settings,
            exportedAt: new Date().toISOString(),
            version: '2.3'
        };

        let content, filename, mimeType;

        switch (format) {
            case 'json':
                content = JSON.stringify(data, null, 2);
                filename = `taskflow-backup-${new Date().toISOString().split('T')[0]}.json`;
                mimeType = 'application/json';
                break;

            case 'csv':
                content = this.convertToCSV(this.tasks);
                filename = `taskflow-tasks-${new Date().toISOString().split('T')[0]}.csv`;
                mimeType = 'text/csv';
                break;

            case 'ics':
                content = this.convertToICS(this.tasks);
                filename = `taskflow-calendar-${new Date().toISOString().split('T')[0]}.ics`;
                mimeType = 'text/calendar';
                break;
        }

        this.downloadFile(content, filename, mimeType);
        this.showNotification(`Data exported as ${format.toUpperCase()}`, 'success');
    }

    convertToCSV(tasks) {
        const headers = ['Title', 'Description', 'Priority', 'Project', 'Tags', 'Due Date', 'Due Time', 'Completed', 'Recurring', 'Created At'];
        const rows = tasks.map(task => [
            task.title,
            task.description || '',
            this.getPriorityLabel(task.priority),
            this.projects.find(p => p.id === task.project)?.name || '',
            task.tags.join('; '),
            task.dueDate || '',
            task.dueTime || '',
            task.completed ? 'Yes' : 'No',
            task.isRecurring ? 'Yes' : 'No',
            task.createdAt
        ]);

        return [headers, ...rows].map(row => 
            row.map(cell => `"${cell}"`).join(',')
        ).join('\n');
    }

    convertToICS(tasks) {
        const lines = [
            'BEGIN:VCALENDAR',
            'VERSION:2.0',
            'PRODID:-//TaskFlow//TaskFlow v2.3//EN',
            'CALSCALE:GREGORIAN'
        ];

        tasks.filter(task => task.dueDate && !task.completed).forEach(task => {
            const startDateTime = new Date(`${task.dueDate}T${task.dueTime || '09:00'}:00`);
            const endDateTime = new Date(startDateTime.getTime() + 60 * 60 * 1000);

            lines.push(
                'BEGIN:VEVENT',
                `UID:${task.id}@taskflow.app`,
                `DTSTART:${this.formatICSDateTime(startDateTime)}`,
                `DTEND:${this.formatICSDateTime(endDateTime)}`,
                `SUMMARY:${task.title}`,
                `DESCRIPTION:${task.description || ''}`,
                `CATEGORIES:${task.tags.join(',')}`,
                `STATUS:${task.completed ? 'COMPLETED' : 'CONFIRMED'}`,
                'END:VEVENT'
            );
        });

        lines.push('END:VCALENDAR');
        return lines.join('\n');
    }

    formatICSDateTime(date) {
        return date.toISOString().replace(/[-:]/g, '').split('.')[0] + 'Z';
    }

    downloadFile(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    clearAllData() {
        if (confirm('‚ö†Ô∏è This will delete ALL tasks, projects, and settings. This cannot be undone. Are you sure?')) {
            if (confirm('Last chance - this will permanently delete everything. Continue?')) {
                localStorage.removeItem('taskflow_tasks');
                localStorage.removeItem('taskflow_projects');
                localStorage.removeItem('taskflow_settings');
                localStorage.removeItem('taskflow_user_emails');
                localStorage.removeItem('taskflow_calendar_accounts');

                this.showNotification('All data cleared. Reloading...', 'success');

                setTimeout(() => {
                    location.reload();
                }, 1000);
            }
        }
    }

    resetAllSettings() {
        if (confirm('This will reset all settings to defaults. Continue?')) {
            localStorage.removeItem('taskflow_settings');
            localStorage.removeItem('taskflow_theme');

            this.showNotification('Settings reset to defaults', 'success');

            setTimeout(() => {
                location.reload();
            }, 1000);
        }
    }

    getPriorityClass(priority) {
        if (priority.important && priority.immediate) {
            return 'priority-important-immediate';
        } else if (priority.important && !priority.immediate) {
            return 'priority-important-not-immediate';
        } else if (!priority.important && priority.immediate) {
            return 'priority-immediate-not-important';
        } else {
            return 'priority-not-important-not-immediate';
        }
    }

    getPriorityKey(priority) {
        if (priority.important && priority.immediate) {
            return 'important-immediate';
        } else if (priority.important && !priority.immediate) {
            return 'important-not-immediate';
        } else if (!priority.important && priority.immediate) {
            return 'immediate-not-important';
        } else {
            return 'not-important-not-immediate';
        }
    }

    getPriorityLabel(priority) {
        if (priority.important && priority.immediate) {
            return 'Do First';
        } else if (priority.important && !priority.immediate) {
            return 'Schedule';
        } else if (!priority.important && priority.immediate) {
            return 'Delegate';
        } else {
            return 'Eliminate';
        }
    }

    formatDate(dateString) {
        if (!dateString) return 'No date';

        const date = new Date(dateString);
        const today = new Date();
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);

        if (date.toDateString() === today.toDateString()) {
            return 'Today';
        } else if (date.toDateString() === tomorrow.toDateString()) {
            return 'Tomorrow';
        } else {
            return date.toLocaleDateString(undefined, { 
                month: 'short', 
                day: 'numeric'
            });
        }
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    showNotification(message, type = 'info') {
        console.log(`Notification [${type}]:`, message);

        document.querySelectorAll('.notification').forEach(n => n.remove());

        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
            <span>${this.escapeHtml(message)}</span>
            <button onclick="this.parentElement.remove()" style="margin-left: auto; background: none; border: none; font-size: 18px; cursor: pointer; color: inherit;">&times;</button>
        `;

        notification.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: var(--bg-primary, #ffffff);
            border: 1px solid var(--border-color, #e5e7eb);
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            max-width: 300px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-left: 4px solid ${type === 'success' ? '#34a853' : type === 'error' ? '#ea4335' : '#4285f4'};
            color: var(--text-primary, #333);
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, 5000);
    }

    async saveTasks() {
        // Save to localStorage for backward compatibility
        localStorage.setItem('taskflow_tasks', JSON.stringify(this.tasks));
        
        // If using Firebase, sync to Firestore
        if (this.useFirestore && this.firebaseUserId) {
            try {
                // Save all tasks to Firestore
                for (const task of this.tasks) {
                    await window.FirebaseManager.saveTask(this.firebaseUserId, task);
                }
            } catch (error) {
                console.error('‚ùå Error saving to Firestore:', error);
                // Don't show error to user - localStorage still works
            }
        }
    }

    async saveProjects() {
        // Save to localStorage for backward compatibility
        localStorage.setItem('taskflow_projects', JSON.stringify(this.projects));
        
        // If using Firebase, sync to Firestore
        if (this.useFirestore && this.firebaseUserId) {
            try {
                // Save all projects to Firestore
                for (const project of this.projects) {
                    await window.FirebaseManager.saveProject(this.firebaseUserId, project);
                }
            } catch (error) {
                console.error('‚ùå Error saving projects to Firestore:', error);
            }
        }
    }

    saveUserEmails() {
        localStorage.setItem('taskflow_user_emails', JSON.stringify(this.userEmails));
    }

    saveCalendarAccounts() {
        localStorage.setItem('taskflow_calendar_accounts', JSON.stringify(this.calendarAccounts));
    }

    filterByProject(projectId) {
        this.showNotification('Project filtering coming soon!', 'info');
    }

    async createCalendarEventWithFeedback(task, isAIRecommended = false) {
        try {
            console.log('ü§ñ createCalendarEventWithFeedback called:', {
                taskTitle: task.title,
                isAIRecommended,
                hasDate: !!task.dueDate,
                hasTime: !!task.dueTime,
                calendarReady: this.isGoogleCalendarReady()
            });
            
            // Show loading state
            const loadingMessage = isAIRecommended ? 
                `ü§ñ AI is creating calendar reminder for "${task.title}"...` :
                `üìÖ Creating calendar event for "${task.title}"...`;
            
            this.showNotification(loadingMessage, 'info');
            
            // Create the calendar event
            const result = await this.createCalendarEvent(task);
            
            if (result) {
                task.aiReminderCreated = isAIRecommended;
                this.saveTasks();
                
                // Show success with visual feedback
                const successMessage = isAIRecommended ?
                    `ü§ñ‚úÖ AI created calendar reminder for "${task.title}"` :
                    `üìÖ‚úÖ Calendar event created for "${task.title}"`;
                
                this.showNotification(successMessage, 'success');
                
                // Add visual indicator to the task in UI
                this.addCalendarIndicatorToTask(task.id, isAIRecommended);
                
                // Re-render the current view to show the indicator
                this.renderCurrentView();
            }
        } catch (error) {
            console.error('Failed to create calendar event with feedback:', error);
            this.showNotification(`Failed to create calendar reminder: ${error.message}`, 'error');
        }
    }
    
    addCalendarIndicatorToTask(taskId, isAICreated = false) {
        // Find the task element in the UI and add visual indicator
        setTimeout(() => {
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            if (taskElement) {
                const indicator = document.createElement('span');
                indicator.className = `calendar-indicator ${isAICreated ? 'ai-created' : 'manual-created'}`;
                indicator.innerHTML = isAICreated ? 
                    '<i class="fas fa-robot"></i><i class="fas fa-calendar-plus"></i>' :
                    '<i class="fas fa-calendar-check"></i>';
                indicator.title = isAICreated ? 
                    'AI created calendar reminder' : 
                    'Calendar reminder created';
                
                const titleElement = taskElement.querySelector('.task-title');
                if (titleElement && !titleElement.querySelector('.calendar-indicator')) {
                    titleElement.appendChild(indicator);
                }
            }
        }, 500); // Small delay to ensure task is rendered
    }

    async createCalendarEvent(task) {
        console.log('üìÖ Creating calendar event for task:', task.title);

        if (!task.dueDate || !task.dueTime) {
            console.log('‚ùå Task missing date/time for calendar event');
            this.showNotification('Task needs both date and time to create calendar event', 'error');
            return null;
        }

        // Check if Google Calendar is connected and ready
        if (!this.isGoogleCalendarReady()) {
            console.log('‚ùå Google Calendar not connected');
            this.showNotification('Please connect Google Calendar first', 'error');
            return null;
        }

        try {
            // Get selected calendar ID - use default if none selected
            const eventCalendarSelect = document.getElementById('eventCalendar');
            let calendarId = 'primary';
            
            if (eventCalendarSelect && eventCalendarSelect.value) {
                const [accountId, calId] = eventCalendarSelect.value.split(':');
                calendarId = calId || 'primary';
            } else if (this.defaultCalendarId) {
                // Use default calendar from settings
                const [accountId, calId] = this.defaultCalendarId.split(':');
                calendarId = calId || 'primary';
            }

            // Create the calendar event
            const calendarEvent = await this.createGoogleCalendarEvent(task, calendarId);
            
            // Store event info in task
            task.calendarEvent = {
                id: calendarEvent.id,
                provider: 'google',
                calendarId: calendarId,
                url: calendarEvent.htmlLink
            };

            this.saveTasks();
            this.showNotification(`Calendar event created for "${task.title}"`, 'success');

            return task.calendarEvent;

        } catch (error) {
            console.error('Failed to create calendar event:', error);
            this.showNotification(`Failed to create calendar event: ${error.message}`, 'error');
            return null;
        }
    }

    importData() {
        document.getElementById('importFile').click();
    }

    // NEW TASK ACTION METHODS

    editTask(taskId) {
        console.log('‚úèÔ∏è Editing task:', taskId);
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) {
            console.error('Task not found:', taskId);
            return;
        }

        // Populate the add task modal with existing task data
        document.getElementById('taskTitle').value = task.title;
        document.getElementById('taskDescription').value = task.description || '';
        
        // Set priority - select the correct button
        const priorityValue = this.convertPriorityToString(task.priority);
        document.querySelectorAll('.priority-option-fixed').forEach(btn => {
            btn.classList.remove('selected');
            if (btn.dataset.priority === priorityValue) {
                btn.classList.add('selected');
            }
        });
        
        // Set project
        document.getElementById('taskProject').value = task.project || '';
        
        // Set tags
        document.getElementById('taskTags').value = task.tags ? task.tags.join(', ') : '';
        
        // Set date and time
        document.getElementById('taskDate').value = task.dueDate || '';
        document.getElementById('taskTime').value = task.dueTime || '';
        
        // Set recurrence
        document.getElementById('taskRecurrence').value = task.recurrence || 'none';
        
        // Set calendar event checkbox
        document.getElementById('createCalendarEvent').checked = !!task.calendarEvent;

        // Change modal title and button
        document.querySelector('#addTaskModal .modal-header h2').textContent = 'Edit Task';
        document.querySelector('#addTaskModal .btn--primary').textContent = 'Update Task';
        
        // Store the task ID for update
        this.editingTaskId = taskId;
        
        // Show modal
        this.showAddTaskModal();
    }

    expandTask(taskId) {
        console.log('üîç Expanding task:', taskId);
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) {
            console.error('Task not found:', taskId);
            return;
        }

        const project = this.projects.find(p => p.id === task.project);
        const priorityLabel = this.getPriorityLabel(task.priority);
        
        // Populate expanded modal
        document.getElementById('expandedTaskTitle').textContent = task.title;
        
        const bodyHtml = `
            <div class="task-detail-row">
                <span class="task-detail-label">Description:</span>
                <span class="task-detail-value">${task.description || 'No description provided'}</span>
            </div>
            
            <div class="task-detail-row">
                <span class="task-detail-label">Priority:</span>
                <span class="task-detail-value">
                    <span class="task-priority-badge ${this.getPriorityClass(task.priority)}">
                        <i class="fas fa-${this.getPriorityIcon(task.priority)}"></i>
                        ${priorityLabel}
                    </span>
                </span>
            </div>
            
            ${project ? `
                <div class="task-detail-row">
                    <span class="task-detail-label">Project:</span>
                    <span class="task-detail-value" style="color: ${project.color}; font-weight: 500;">${project.name}</span>
                </div>
            ` : ''}
            
            ${task.tags && task.tags.length > 0 ? `
                <div class="task-detail-row">
                    <span class="task-detail-label">Tags:</span>
                    <span class="task-detail-value">
                        <div class="task-tags">
                            ${task.tags.map(tag => `<span class="task-tag">${this.escapeHtml(tag)}</span>`).join('')}
                        </div>
                    </span>
                </div>
            ` : ''}
            
            ${task.dueDate ? `
                <div class="task-detail-row">
                    <span class="task-detail-label">Due Date:</span>
                    <span class="task-detail-value">
                        <i class="fas fa-calendar"></i>
                        ${this.formatDate(task.dueDate)}
                        ${task.dueTime ? ' at ' + task.dueTime : ''}
                    </span>
                </div>
            ` : ''}
            
            <div class="task-detail-row">
                <span class="task-detail-label">Status:</span>
                <span class="task-detail-value">
                    <span style="color: ${task.completed ? '#10b981' : '#f59e0b'}; font-weight: 500;">
                        <i class="fas fa-${task.completed ? 'check-circle' : 'clock'}"></i>
                        ${task.completed ? 'Completed' : 'In Progress'}
                    </span>
                </span>
            </div>
            
            <div class="task-detail-row">
                <span class="task-detail-label">Created:</span>
                <span class="task-detail-value">${this.formatDate(task.createdAt || new Date().toISOString().split('T')[0])}</span>
            </div>
            
            ${task.calendarEventId ? `
                <div class="task-detail-row">
                    <span class="task-detail-label">Calendar:</span>
                    <span class="task-detail-value">
                        <i class="fas fa-calendar-check" style="color: #10b981;"></i>
                        Calendar event created
                    </span>
                </div>
            ` : ''}
            
            ${task.isRecurring ? `
                <div class="task-detail-row">
                    <span class="task-detail-label">Recurrence:</span>
                    <span class="task-detail-value">
                        <i class="fas fa-redo"></i>
                        ${task.recurrence || 'Recurring task'}
                    </span>
                </div>
            ` : ''}
        `;
        
        document.getElementById('expandedTaskBody').innerHTML = bodyHtml;
        
        // Show modal
        const modal = document.getElementById('taskExpandedModal');
        modal.classList.add('show');
    }

    closeExpandedTask() {
        const modal = document.getElementById('taskExpandedModal');
        modal.classList.remove('show');
    }

    async deleteTask(taskId) {
        console.log('üóëÔ∏è Deleting task:', taskId);
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) {
            console.error('Task not found:', taskId);
            return;
        }

        if (confirm(`Are you sure you want to delete "${task.title}"?`)) {
            console.log('üîç Task details:', {
                id: task.id,
                title: task.title,
                dueDate: task.dueDate,
                dueTime: task.dueTime
            });
            
            // Delete calendar event if auto-delete is enabled
            const autoDeleteEvents = document.getElementById('autoDeleteEvents')?.checked ?? true;
            console.log('‚öôÔ∏è Auto-delete events setting:', autoDeleteEvents);
            
            if (autoDeleteEvents) {
                console.log('üóëÔ∏è Searching for calendar events to delete for task:', task.title);
                try {
                    const deleted = await deleteGoogleCalendarEventByTask(task);
                    if (deleted) {
                        console.log('‚úÖ Calendar event(s) deleted successfully');
                    } else {
                        console.log('‚ÑπÔ∏è No matching calendar events found to delete');
                    }
                } catch (err) {
                    console.error('‚ùå Error deleting calendar event:', err);
                    // Continue with task deletion even if calendar deletion fails
                }
            } else {
                console.log('‚ÑπÔ∏è Calendar event deletion disabled in settings');
            }

            // Remove from tasks array
            this.tasks = this.tasks.filter(t => t.id !== taskId);
            
            // Delete from Firestore if authenticated
            if (this.useFirestore && this.firebaseUserId) {
                try {
                    await window.FirebaseManager.deleteTask(this.firebaseUserId, taskId);
                } catch (error) {
                    console.error('‚ùå Error deleting from Firestore:', error);
                }
            }
            
            // Save to localStorage
            this.saveTasks();
            
            // Update UI
            this.renderCurrentView();
            this.updateStats();
            this.updateTaskCounts();
            
            this.showNotification('Task deleted successfully', 'success');
            
            // Show additional notification if calendar events were also deleted
            if (autoDeleteEvents) {
                setTimeout(() => {
                    this.showNotification('Calendar reminders also removed', 'info');
                }, 1000);
            }
        }
    }

    // Utility method to clean up orphaned calendar events
    async cleanupOrphanedCalendarEvents() {
        try {
            console.log('üßπ Starting cleanup of orphaned calendar events...');
            
            // Get all tasks with calendar event IDs
            const tasksWithEvents = this.tasks.filter(task => task.calendarEventId);
            console.log(`Found ${tasksWithEvents.length} tasks with calendar events`);
            
            if (tasksWithEvents.length === 0) {
                this.showNotification('No calendar events to clean up', 'info');
                return;
            }
            
            // Check if user is authenticated
            const token = gapi.client.getToken();
            if (!token) {
                this.showNotification('Please connect Google Calendar first', 'warning');
                return;
            }
            
            let cleaned = 0;
            let failed = 0;
            
            for (const task of tasksWithEvents) {
                try {
                    // Try to get the event to see if it exists
                    await gapi.client.calendar.events.get({
                        'calendarId': 'primary',
                        'eventId': task.calendarEventId
                    });
                    // If no error, event exists - no action needed
                } catch (err) {
                    if (err.status === 404) {
                        // Event doesn't exist - clean up the reference
                        console.log(`üßπ Removing orphaned reference: ${task.calendarEventId}`);
                        task.calendarEventId = null;
                        cleaned++;
                    } else {
                        console.error('Error checking event:', err);
                        failed++;
                    }
                }
            }
            
            if (cleaned > 0) {
                this.saveTasks();
                this.showNotification(`Cleaned up ${cleaned} orphaned calendar references`, 'success');
            } else {
                this.showNotification('No orphaned calendar events found', 'info');
            }
            
            if (failed > 0) {
                console.warn(`Failed to check ${failed} calendar events`);
            }
            
        } catch (err) {
            console.error('Error during calendar cleanup:', err);
            this.showNotification('Error during calendar cleanup', 'error');
        }
    }

    toggleTask(taskId) {
        console.log('‚úÖ Toggling task completion:', taskId);
        const task = this.tasks.find(t => t.id === taskId);
        if (!task) {
            console.error('Task not found:', taskId);
            return;
        }

        task.completed = !task.completed;
        task.completedAt = task.completed ? new Date().toISOString() : null;
        
        // Save to localStorage
        this.saveTasks();
        
        // Update UI
        this.renderCurrentView();
        this.updateStats();
        this.updateTaskCounts();
        
        this.showNotification(
            task.completed ? 'Task marked as completed!' : 'Task marked as incomplete',
            'success'
        );
    }

    // Helper method to get priority icon
    getPriorityIcon(priority) {
        const icons = {
            'important-immediate': 'fire',
            'important-not-immediate': 'star',
            'immediate-not-important': 'bolt',
            'not-important-not-immediate': 'circle'
        };
        return icons[priority] || 'circle';
    }

    // Reset task form to add mode
    resetTaskForm() {
        // Reset modal title and button
        document.querySelector('#addTaskModal .modal-header h2').textContent = 'Add New Task';
        document.querySelector('#addTaskModal .btn--primary').textContent = 'Add Task';
        
        // Clear editing state
        this.editingTaskId = null;
        
        // Reset form
        document.getElementById('taskForm').reset();
        
        // Reset priority to default button
        document.querySelectorAll('.priority-option-fixed').forEach(btn => {
            btn.classList.remove('selected');
            if (btn.dataset.priority === 'not-important-not-immediate') {
                btn.classList.add('selected');
            }
        });
    }

    // Override hideAddTaskModal to reset form
    hideAddTaskModal() {
        const modal = document.getElementById('addTaskModal');
        if (modal) {
            modal.classList.remove('show');
            this.resetTaskForm();
        }
    }
}

// Initialize TaskFlow v3.0 with Firebase
console.log('üöÄ Starting TaskFlow v3.0 with Firebase Cloud Sync...');
window.app = new TaskFlowEnhanced();

// Add window load event for additional safety
window.addEventListener('load', () => {
    console.log('üîÑ Window loaded - checking for saved Google Calendar connection...');
    
    setTimeout(() => {
        const savedEmail = localStorage.getItem('google_account_email');
        const savedToken = localStorage.getItem('google_access_token');
        
        if (savedEmail || savedToken) {
            console.log('üî• FINAL FORCE: Restoring UI for saved connection...');
            
            if (window.app) {
                window.app.forceUpdateConnectedAccountsTable();
                window.app.forcePopulateCalendarDropdown();
                window.app.updateGoogleCalendarConnectedState(true);
            }
        }
    }, 3000); // Wait for all Google APIs to load
});
    </script>

    <script>
        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js');
        }
    </script>
    
    <!-- Firebase Auth Handlers -->
    <script>
        // Toggle between sign in and sign up
        function showSignUp() {
            document.getElementById('signInTab').style.display = 'none';
            document.getElementById('signUpTab').style.display = 'block';
            document.getElementById('authError').style.display = 'none';
        }
        
        function showSignIn() {
            document.getElementById('signUpTab').style.display = 'none';
            document.getElementById('signInTab').style.display = 'block';
            document.getElementById('authError').style.display = 'none';
        }
        
        // Google Sign In
        async function handleGoogleSignIn() {
            try {
                await window.FirebaseManager.signInWithGoogle();
            } catch (error) {
                console.error('Sign in failed:', error);
            }
        }
        
        // Email Sign In
        async function handleEmailSignIn(event) {
            event.preventDefault();
            const email = document.getElementById('signInEmail').value;
            const password = document.getElementById('signInPassword').value;
            
            try {
                await window.FirebaseManager.signInWithEmail(email, password);
            } catch (error) {
                console.error('Sign in failed:', error);
            }
        }
        
        // Email Sign Up
        async function handleEmailSignUp(event) {
            event.preventDefault();
            const email = document.getElementById('signUpEmail').value;
            const password = document.getElementById('signUpPassword').value;
            const confirmPassword = document.getElementById('signUpPasswordConfirm').value;
            
            if (password !== confirmPassword) {
                window.FirebaseManager.showError('Passwords do not match');
                return;
            }
            
            try {
                await window.FirebaseManager.signUpWithEmail(email, password);
            } catch (error) {
                console.error('Sign up failed:', error);
            }
        }
        
        // Add sign out button handler
        function handleSignOut() {
            if (confirm('Are you sure you want to sign out?')) {
                window.FirebaseManager.signOut();
            }
        }
    </script>
    
    </div> <!-- Close app-container -->
</body>
</html>
